#!/usr/bin/env python3
"""
RAG Í∏∞Î∞ò Text-to-SQL ÏãúÏä§ÌÖú
ÎèôÏ†Å Ïä§ÌÇ§Îßà Ï†ïÎ≥¥Î•º Ï†úÍ≥µÌïòÏó¨ ÌïòÎìúÏΩîÎî©Îêú ÌîÑÎ°¨ÌîÑÌä∏Î•º Ï†úÍ±∞
"""

import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from data.supabase_client import SupabaseManager
from rag.schema_manager import SchemaManager
from data.game_record_service import game_record_service
from data.game_preview_service import game_preview_service
import re
import json

class RAGTextToSQL:
    def __init__(self):
        """RAG Í∏∞Î∞ò Text-to-SQL Ï¥àÍ∏∞Ìôî"""
        try:
            self.llm = ChatOpenAI(
                model="gpt-4o-mini",
                temperature=0.1,
                api_key=os.getenv("OPENAI_API_KEY")
            )
            self.supabase = SupabaseManager()
            self.schema_manager = SchemaManager()
            
            print("‚úÖ RAG Í∏∞Î∞ò Text-to-SQL Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
            
        except Exception as e:
            print(f"‚ùå RAG Í∏∞Î∞ò Text-to-SQL Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            raise e
    
    def generate_sql(self, question: str) -> str:
        """ÏûêÏó∞Ïñ¥ ÏßàÎ¨∏ÏùÑ SQLÎ°ú Î≥ÄÌôò (RAG Í∏∞Î∞ò)"""
        try:
            # ÎèôÏ†Å ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
            prompt = self.schema_manager.generate_dynamic_prompt(question)
            
            # SQL ÏÉùÏÑ±
            response = self.llm.invoke(prompt)
            sql = self._extract_sql(response.content)
            
            print(f"üîç ÏÉùÏÑ±Îêú SQL: {sql}")
            return sql
            
        except Exception as e:
            print(f"‚ùå SQL ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return ""
    
    def _extract_sql(self, response: str) -> str:
        """ÏùëÎãµÏóêÏÑú SQL Ï∂îÏ∂ú"""
        # SQL Ï†ïÎ¶¨
        sql = re.sub(r'```sql\s*', '', response)
        sql = re.sub(r'```\s*', '', sql)
        sql = sql.strip()
        
        # ÏÑ§Î™Ö ÌÖçÏä§Ìä∏Í∞Ä Ìè¨Ìï®Îêú Í≤ΩÏö∞ SQLÎßå Ï∂îÏ∂ú
        sql_match = re.search(r'SELECT.*?;', sql, re.DOTALL | re.IGNORECASE)
        if sql_match:
            sql = sql_match.group(0).strip()
        
        return sql
    
    def execute_sql(self, sql: str, question: str = "") -> list:
        """SQL Ïã§Ìñâ"""
        try:
            # Í∞ÑÎã®Ìïú SELECT ÏøºÎ¶¨Îßå ÏßÄÏõê
            if not sql.upper().startswith('SELECT'):
                return []
            
            # DB_ERROR Ï≤¥ÌÅ¨
            if "DB_ERROR:" in sql.upper():
                return [sql]
            
            # game_schedule ÌÖåÏù¥Î∏î Ï°∞Ìöå
            if "game_schedule" in sql.lower():
                return self._get_game_schedule_data(sql, question)
            
            # game_result ÌÖåÏù¥Î∏î Ï°∞Ìöå
            if "game_result" in sql.lower():
                return self._get_game_result_data(sql)
            
            # ÏÑ†Ïàò Í¥ÄÎ†® ÌÖåÏù¥Î∏î Ï°∞Ìöå
            if any(table in sql.lower() for table in ['player_season_stats', 'player_game_stats']):
                return self._query_player_data(sql, question)
                
        except Exception as e:
            print(f"‚ùå Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return ["DB_ERROR: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."]
    
    def _query_player_data(self, sql: str, question: str = "") -> list:
        """ÏÑ†Ïàò Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        try:
            # SQLÏóêÏÑú ÏÑ†ÏàòÎ™Ö Ï∂îÏ∂ú
            player_names = self._extract_player_names_from_sql(sql)
            print(f"üîç SQLÏóêÏÑú Ï∂îÏ∂úÎêú ÏÑ†ÏàòÎ™Ö: {player_names}")
            
            if player_names:
                # ÌäπÏ†ï ÏÑ†ÏàòÎ™ÖÏù¥ ÏûàÎäî Í≤ΩÏö∞
                all_data = []
                for player_name in player_names:
                    print(f"üîç ÏÑ†Ïàò '{player_name}' Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë...")
                    player_data = self.supabase.get_player_complete_data(player_name)
                    if player_data:
                        print(f"‚úÖ ÏÑ†Ïàò '{player_name}' Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÏÑ±Í≥µ")
                        all_data.append(player_data)
                    else:
                        print(f"‚ùå ÏÑ†Ïàò '{player_name}' Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
                return all_data
            else:
                # ÏÑ†ÏàòÎ™ÖÏù¥ ÏóÜÎäî Í≤ΩÏö∞ (ÌåÄÎ≥Ñ ÌÜµÍ≥Ñ Ï°∞Ìöå Îì±) - ÏßÅÏ†ë SQL Ïã§Ìñâ
                print("üîç ÏÑ†ÏàòÎ™ÖÏù¥ ÏóÜÏúºÎØÄÎ°ú ÏßÅÏ†ë SQL Ïã§Ìñâ")
                return self._execute_direct_sql(sql, question)
        except Exception as e:
            print(f"‚ùå ÏÑ†Ïàò Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return []
    
    def _execute_direct_sql(self, sql: str, question: str = "") -> list:
        """SQLÏùÑ ÏßÅÏ†ë Ïã§ÌñâÌïòÏó¨ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        try:
            # SQL ÌååÏã±ÌïòÏó¨ WHERE Ï°∞Í±¥ Ï∂îÏ∂ú
            where_conditions = self._extract_where_conditions(sql)
            print(f"üîç Ï∂îÏ∂úÎêú WHERE Ï°∞Í±¥: {where_conditions}")
            
            # Ìà¨Ïàò/ÌÉÄÏûê Íµ¨Î∂ÑÏùÑ ÏúÑÌïú ÌïÑÌÑ∞ÎßÅ
            player_type = self._determine_player_type(sql)
            print(f"üîç ÏÑ†Ïàò Ïú†Ìòï: {player_type}")
            
            # player_season_stats ÌÖåÏù¥Î∏î Ï°∞Ìöå
            query = self.supabase.supabase.table("player_season_stats").select("*")
            
            # WHERE Ï°∞Í±¥ Ï†ÅÏö©
            for col, val in where_conditions.items():
                query = query.eq(col, val)
            
            # Ìà¨Ïàò/ÌÉÄÏûê ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©
            if player_type == "batter":
                # ÌÉÄÏûê: hraÍ∞Ä NULLÏù¥ ÏïÑÎãå ÏÑ†ÏàòÎì§
                query = query.not_.is_("hra", "null")
            elif player_type == "pitcher":
                # Ìà¨Ïàò: eraÍ∞Ä NULLÏù¥ ÏïÑÎãå ÏÑ†ÏàòÎì§
                query = query.not_.is_("era", "null")
            
            # hra Ïª¨ÎüºÏùÑ ÏÇ¨Ïö©ÌïòÎäî Î™®Îì† ÏßàÎ¨∏Ïóê ÎåÄÌï¥ NULL Í∞í Ï†úÏô∏
            if "hra" in sql.lower() or "ÌÉÄÏú®" in question:
                print("üîç hra NULL Í∞í Ï†úÏô∏ ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©")
                query = query.not_.is_("hra", "null")
            
            # Í∑úÏ†ïÌÉÄÏÑù ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö© (ÌÉÄÏú® Í¥ÄÎ†® ÏßàÎ¨∏Ïù∏ Í≤ΩÏö∞)
            if ("hra" in sql.lower() or "ÌÉÄÏú®" in question) and player_type in ["batter", "both"]:
                # Í∞Å ÌåÄÎ≥ÑÎ°ú Í∑úÏ†ïÌÉÄÏÑù Í≥ÑÏÇ∞
                team_games = self._get_team_games_count()
                print(f"üîç ÌåÄÎ≥Ñ Í≤ΩÍ∏∞ Ïàò: {team_games}")
                
                # ÌÉÄÏú® ÏßàÎ¨∏Ïù∏ Í≤ΩÏö∞ ÌÉÄÏûêÎßå ÌïÑÌÑ∞ÎßÅ
                if player_type == "both":
                    query = query.not_.is_("hra", "null")
                
                # ÌåÄÎ≥Ñ Í∑úÏ†ïÌÉÄÏÑù ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©
                if where_conditions.get('team'):
                    # ÌäπÏ†ï ÌåÄ ÏßàÎ¨∏Ïù∏ Í≤ΩÏö∞
                    team = where_conditions['team']
                    if team in team_games:
                        required_pa = int(team_games[team] * 3.1)
                        print(f"üîç {team} ÌåÄ Í∑úÏ†ïÌÉÄÏÑù ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©: {required_pa}ÌÉÄÏÑù Ïù¥ÏÉÅ")
                        query = query.gte("ab", required_pa)
                    else:
                        print(f"‚ö†Ô∏è {team} ÌåÄÏùò Í≤ΩÍ∏∞ ÏàòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå")
                else:
                    # Î™®Îì† ÌåÄ ÏßàÎ¨∏Ïù∏ Í≤ΩÏö∞ - ÌèâÍ∑† Í≤ΩÍ∏∞ Ïàò ÏÇ¨Ïö©
                    avg_games = sum(team_games.values()) / len(team_games)
                    required_pa = int(avg_games * 3.1)
                    print(f"üîç Ï†ÑÏ≤¥ ÌåÄ ÌèâÍ∑† Í∑úÏ†ïÌÉÄÏÑù ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©: {required_pa}ÌÉÄÏÑù Ïù¥ÏÉÅ")
                    query = query.gte("ab", required_pa)
            
            # ORDER BYÏôÄ LIMIT Ï≤òÎ¶¨ - ÏùºÎ∞òÏ†ÅÏù∏ Î∞©ÏãùÏúºÎ°ú Ï≤òÎ¶¨
            order_by_match = re.search(r'ORDER BY\s+(\w+)\s+(DESC|ASC)', sql, re.IGNORECASE)
            limit_match = re.search(r'LIMIT\s+(\d+)', sql, re.IGNORECASE)
            
            if order_by_match and limit_match:
                # ORDER BY + LIMIT Ï°∞Ìï©Ïù∏ Í≤ΩÏö∞: Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏ÏôÄÏÑú Ï†ïÎ†¨ ÌõÑ Ï†úÌïú
                column = order_by_match.group(1).lower()
                direction = order_by_match.group(2).upper()
                limit_count = int(limit_match.group(1))
                
                result = query.execute()
                data = result.data or []
                
                # PythonÏóêÏÑú Ï†ïÎ†¨ (NULL Í∞íÏùÄ 0ÏúºÎ°ú Ï≤òÎ¶¨)
                reverse = (direction == 'DESC')
                data = sorted(data, key=lambda x: x.get(column, 0) or 0, reverse=reverse)
                data = data[:limit_count]
            elif order_by_match:
                # ORDER BYÎßå ÏûàÎäî Í≤ΩÏö∞: Supabase ORDER BY ÏÇ¨Ïö©
                column = order_by_match.group(1).lower()
                direction = order_by_match.group(2).upper()
                query = query.order(column, desc=(direction == 'DESC'))
                result = query.execute()
                data = result.data or []
            elif limit_match:
                # LIMITÎßå ÏûàÎäî Í≤ΩÏö∞
                limit_count = int(limit_match.group(1))
                query = query.limit(limit_count)
                result = query.execute()
                data = result.data or []
            else:
                # ORDER BYÏôÄ LIMITÏù¥ ÏóÜÎäî Í≤ΩÏö∞
                result = query.execute()
                data = result.data or []
            
            print(f"‚úÖ ÏßÅÏ†ë SQL Ïã§Ìñâ Í≤∞Í≥º: {len(data)}Í∞ú")
            if data:
                print(f"üîç Ï≤´ Î≤àÏß∏ Í≤∞Í≥º: {data[0].get('player_name', 'Unknown')} - ÌôàÎü∞: {data[0].get('hr', 0)}")
            return data
            
        except Exception as e:
            print(f"‚ùå ÏßÅÏ†ë SQL Ïã§Ìñâ Ïò§Î•ò: {e}")
            return []
    
    def _extract_where_conditions(self, sql: str) -> dict:
        """SQLÏóêÏÑú WHERE Ï°∞Í±¥ Ï∂îÏ∂ú"""
        import re
        conditions = {}
        
        # WHERE Ï†à Ï∞æÍ∏∞
        where_match = re.search(r'WHERE\s+(.+?)(?:\s+ORDER|\s+LIMIT|$)', sql, re.IGNORECASE | re.DOTALL)
        if where_match:
            where_clause = where_match.group(1)
            
            # Í∞Å Ï°∞Í±¥ ÌååÏã± (column = 'value' ÌòïÌÉú)
            pattern = r"(\w+)\s*=\s*['\"]([^'\"]+)['\"]"
            matches = re.findall(pattern, where_clause)
            
            for col, val in matches:
                conditions[col] = val
        
        return conditions
    
    def _determine_player_type(self, sql: str) -> str:
        """SQLÏóêÏÑú Ìà¨Ïàò/ÌÉÄÏûê Ïú†Ìòï ÌåêÎã®"""
        import re
        
        # Ìà¨Ïàò Í¥ÄÎ†® ÌÇ§ÏõåÎìú (Î™ÖÌôïÌïú Ìà¨Ïàò Ï†ÑÏö© ÌÇ§ÏõåÎìúÎßå)
        pitcher_keywords = [
            'era', 'w', 'l', 'sv', 'hold', 'cg', 'sho', 'bf', 'inn', 'er', 
            'whip', 'k9', 'bb9', 'kbb', 'qs', 'wra', 'Ìà¨Ïàò', 'ÏÑ†Î∞ú', 'Íµ¨Ïõê', 'ÎßàÎ¨¥Î¶¨'
        ]
        
        # ÌÉÄÏûê Í¥ÄÎ†® ÌÇ§ÏõåÎìú (Î™ÖÌôïÌïú ÌÉÄÏûê Ï†ÑÏö© ÌÇ§ÏõåÎìú)
        batter_keywords = [
            'hra', 'hr', 'h2', 'h3', 'rbi', 'ab', 'obp', 'slg', 'ops', 'isop', 
            'babip', 'wrcplus', 'woba', 'wpa', 'ÌÉÄÏûê', 'ÌÉÄÏú®', 'ÌôàÎü∞', 'ÌÉÄÏ†ê', 
            'ÎìùÏ†ê', 'ÏïàÌÉÄ', 'ÌÉÄÏàò', 'Ï∂úÎ£®Ïú®', 'Ïû•ÌÉÄÏú®'
        ]
        
        # Í≥µÌÜµ ÌÇ§ÏõåÎìú (Ìà¨ÏàòÏôÄ ÌÉÄÏûê Î™®Îëê ÏÇ¨Ïö©)
        common_keywords = ['run', 'hit', 'bb', 'hp', 'kk']
        
        sql_lower = sql.lower()
        
        # Ìà¨Ïàò ÌÇ§ÏõåÎìú Ï≤¥ÌÅ¨ (Í≥µÌÜµ ÌÇ§ÏõåÎìú Ï†úÏô∏)
        pitcher_score = sum(1 for keyword in pitcher_keywords if keyword in sql_lower)
        
        # ÌÉÄÏûê ÌÇ§ÏõåÎìú Ï≤¥ÌÅ¨ (Í≥µÌÜµ ÌÇ§ÏõåÎìú Ï†úÏô∏)
        batter_score = sum(1 for keyword in batter_keywords if keyword in sql_lower)
        
        # ORDER BY Ï†àÏóêÏÑú Ïª¨ÎüºÎ™ÖÏúºÎ°úÎèÑ ÌåêÎã® (Í∞ÄÏ§ëÏπò Îß§Ïö∞ ÎÜíÍ≤å)
        # ÌÖåÏù¥Î∏î Î≥ÑÏπ≠Ïù¥ ÏûàÎäî Í≤ΩÏö∞ÏôÄ ÏóÜÎäî Í≤ΩÏö∞ Î™®Îëê Ï≤òÎ¶¨
        order_by_match = re.search(r'ORDER BY\s+(?:[\w.]+\.)?(\w+)', sql, re.IGNORECASE)
        if order_by_match:
            column = order_by_match.group(1).lower()
            if column in pitcher_keywords:
                pitcher_score += 10  # ORDER BYÎäî Îß§Ïö∞ Ï§ëÏöîÌïú Îã®ÏÑú
            elif column in batter_keywords:
                batter_score += 10  # ORDER BYÎäî Îß§Ïö∞ Ï§ëÏöîÌïú Îã®ÏÑú
        
        # SELECT Ï†àÏóêÏÑú Ïª¨ÎüºÎ™ÖÏúºÎ°úÎèÑ ÌåêÎã® (Í∞ÄÏ§ëÏπò ÎÜíÍ≤å)
        select_match = re.search(r'SELECT\s+(.+?)\s+FROM', sql, re.IGNORECASE | re.DOTALL)
        if select_match:
            select_columns = select_match.group(1).lower()
            for keyword in pitcher_keywords:
                if keyword in select_columns:
                    pitcher_score += 3  # SELECT Ï†àÎèÑ Ï§ëÏöî
            for keyword in batter_keywords:
                if keyword in select_columns:
                    batter_score += 3  # SELECT Ï†àÎèÑ Ï§ëÏöî
        
        
        print(f"üîç Ìà¨Ïàò Ï†êÏàò: {pitcher_score}, ÌÉÄÏûê Ï†êÏàò: {batter_score}")
        
        if pitcher_score > batter_score:
            return "pitcher"
        elif batter_score > pitcher_score:
            return "batter"
        else:
            return "both"  # Íµ¨Î∂ÑÏù¥ Ïñ¥Î†§Ïö¥ Í≤ΩÏö∞
    
    def _extract_player_names_from_sql(self, sql: str) -> list:
        """SQLÏóêÏÑú ÏÑ†ÏàòÎ™Ö Ï∂îÏ∂ú"""
        import re
        
        # ÌåÄ ÏΩîÎìú Î™©Î°ù (ÏÑ†ÏàòÎ™ÖÏù¥ ÏïÑÎãå Í≤ÉÎì§)
        team_codes = {'HH', 'OB', 'HT', 'WO', 'LT', 'SS', 'SK', 'KT', 'NC', 'LG'}
        
        all_matches = []
        
        # 1. player_name IN ('ÏÑ†ÏàòÎ™Ö1', 'ÏÑ†ÏàòÎ™Ö2') Ìå®ÌÑ¥ Ï∞æÍ∏∞
        pattern1 = r"player_name\s+IN\s*\(\s*['\"]([^'\"]+)['\"]\s*,\s*['\"]([^'\"]+)['\"]\s*\)"
        matches1 = re.findall(pattern1, sql, re.IGNORECASE)
        for match in matches1:
            all_matches.extend(match)
        
        # 2. player_name = 'ÏÑ†ÏàòÎ™Ö' OR player_name = 'ÏÑ†ÏàòÎ™Ö' Ìå®ÌÑ¥ Ï∞æÍ∏∞
        pattern2 = r"player_name\s*=\s*['\"]([^'\"]+)['\"]"
        matches2 = re.findall(pattern2, sql, re.IGNORECASE)
        all_matches.extend(matches2)
        
        # 3. (p.player_name = 'ÏÑ†ÏàòÎ™Ö' OR p.player_name = 'ÏÑ†ÏàòÎ™Ö') Ìå®ÌÑ¥ Ï∞æÍ∏∞
        pattern3 = r"p\.player_name\s*=\s*['\"]([^'\"]+)['\"]"
        matches3 = re.findall(pattern3, sql, re.IGNORECASE)
        all_matches.extend(matches3)
        
        print(f"üîç SQL Ìå®ÌÑ¥ Îß§Ïπ≠ Í≤∞Í≥º: {all_matches}")
        
        # ÌåÄ ÏΩîÎìúÍ∞Ä ÏïÑÎãå Ïã§Ï†ú ÏÑ†ÏàòÎ™ÖÎßå ÌïÑÌÑ∞ÎßÅ
        player_names = [name for name in all_matches if name.upper() not in team_codes]
        
        # ÎßåÏïΩ WHERE Ï†àÏóêÏÑú ÏÑ†ÏàòÎ™ÖÏùÑ Ï∞æÏßÄ Î™ªÌñàÎã§Î©¥, Ïù¥Îäî ÌÜµÍ≥Ñ Ï°∞Ìöå ÏøºÎ¶¨Ïù¥ÎØÄÎ°ú Îπà Î¶¨Ïä§Ìä∏ Î∞òÌôò
        # (Ïòà: SELECT player_name, hr FROM ... WHERE team = 'ÌïúÌôî' ORDER BY hr DESC)
        if not player_names:
            print("üîç WHERE Ï†àÏóêÏÑú ÏÑ†ÏàòÎ™ÖÏùÑ Ï∞æÏßÄ Î™ªÌï® - ÌÜµÍ≥Ñ Ï°∞Ìöå ÏøºÎ¶¨Î°ú ÌåêÎã®")
        
        return player_names
    
    def _get_team_games_count(self) -> dict:
        """Í∞Å ÌåÄÏùò ÏµúÎåÄ Í≤ΩÍ∏∞ ÏàòÎ•º Í≥ÑÏÇ∞"""
        try:
            result = self.supabase.supabase.table("player_season_stats").select("team, gamenum").eq("gyear", "2025").execute()
            
            team_games = {}
            for player in result.data:
                team = player['team']
                gamenum = player['gamenum']
                if team not in team_games or gamenum > team_games[team]:
                    team_games[team] = gamenum
            
            return team_games
        except Exception as e:
            print(f"‚ùå ÌåÄ Í≤ΩÍ∏∞ Ïàò Ï°∞Ìöå Ïò§Î•ò: {e}")
            # Í∏∞Î≥∏Í∞í Î∞òÌôò
            return {"ÌïúÌôî": 128, "ÎëêÏÇ∞": 123, "LG": 128, "NC": 126, "SSG": 125, 
                   "KIA": 117, "KT": 116, "Î°ØÎç∞": 130, "ÏÇºÏÑ±": 129, "ÌÇ§ÏõÄ": 130}
    
    def _get_game_schedule_data(self, sql: str, question: str = "") -> list:
        """Í≤ΩÍ∏∞ ÏùºÏ†ï Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        try:
            # RAG ÏãúÏä§ÌÖúÏù¥ ÏÉùÏÑ±Ìïú SQLÏùÑ ÏßÅÏ†ë Ïã§Ìñâ
            print(f"üîç RAG SQL Ïã§Ìñâ: {sql}")
            
            # SQLÏóêÏÑú SELECT Ï†à Ï∂îÏ∂ú
            if "SELECT" in sql.upper():
                # Í∞ÑÎã®Ìïú SQL ÌååÏã± (WHERE Ï†àÎßå Ï∂îÏ∂ú)
                where_clause = ""
                if "WHERE" in sql.upper():
                    where_start = sql.upper().find("WHERE")
                    where_clause = sql[where_start:]
                    # ORDER BY, LIMIT Ï†úÍ±∞
                    if "ORDER BY" in where_clause.upper():
                        where_clause = where_clause[:where_clause.upper().find("ORDER BY")]
                    if "LIMIT" in where_clause.upper():
                        where_clause = where_clause[:where_clause.upper().find("LIMIT")]
                    where_clause = where_clause.strip()
                
                # Supabase ÏøºÎ¶¨ Ïã§Ìñâ
                query = self.supabase.supabase.table("game_schedule").select("*")
                
                # WHERE Ï†àÏù¥ ÏûàÏúºÎ©¥ Ï†ÅÏö©
                if where_clause:
                    # ÌåÄÎ™Ö Ï°∞Í±¥ ÌååÏã±
                    if "ÌïúÌôî" in where_clause:
                        # ÌïúÌôî Ìôà Í≤ΩÍ∏∞ÏôÄ ÏõêÏ†ï Í≤ΩÍ∏∞Î•º Í∞ÅÍ∞Å Ï°∞Ìöå
                        home_games = self.supabase.supabase.table("game_schedule").select("*").eq("home_team_name", "ÌïúÌôî").execute()
                        away_games = self.supabase.supabase.table("game_schedule").select("*").eq("away_team_name", "ÌïúÌôî").execute()
                        
                        # ÎÇ†Ïßú Ï°∞Í±¥ Ï†ÅÏö©
                        if "game_date::date >= CURRENT_DATE" in where_clause:
                            from datetime import datetime
                            today = datetime.now().strftime("%Y-%m-%d")
                            
                            # Ìôà Í≤ΩÍ∏∞ ÌïÑÌÑ∞ÎßÅ
                            home_filtered = [game for game in home_games.data if game.get('game_date', '') >= today]
                            # ÏõêÏ†ï Í≤ΩÍ∏∞ ÌïÑÌÑ∞ÎßÅ
                            away_filtered = [game for game in away_games.data if game.get('game_date', '') >= today]
                            
                            # Í≤∞Í≥º Ìï©ÏπòÍ∏∞
                            all_games = home_filtered + away_filtered
                            # ÎÇ†ÏßúÏàú Ï†ïÎ†¨
                            all_games.sort(key=lambda x: x.get('game_date', ''))
                            return all_games
                        else:
                            # ÎÇ†Ïßú Ï°∞Í±¥ ÏóÜÏù¥ Î™®Îì† Í≤ΩÍ∏∞ Î∞òÌôò
                            all_games = home_games.data + away_games.data
                            all_games.sort(key=lambda x: x.get('game_date', ''))
                            return all_games
                
                result = query.execute()
                return result.data if result.data else []
            
            # Í∏∞Î≥∏ Ï°∞Ìöå (SQLÏù¥ Î≥µÏû°Ìïú Í≤ΩÏö∞)
            result = self.supabase.supabase.table("game_schedule").select("*").execute()
            return result.data if result.data else []
            
        except Exception as e:
            print(f"‚ùå Í≤ΩÍ∏∞ ÏùºÏ†ï Ï°∞Ìöå Ïò§Î•ò: {e}")
            return []
    
    def _get_game_result_data(self, sql: str) -> list:
        """ÌåÄ ÏàúÏúÑ Î∞è ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        try:
            result = self.supabase.supabase.table("game_result").select("*").execute()
            
            if not result.data:
                return []
            
            print(f"üìä ÌåÄ ÏàúÏúÑ Î∞è ÌÜµÍ≥Ñ Ï°∞Ìöå: {len(result.data)}Í∞ú")
            return result.data
            
        except Exception as e:
            print(f"‚ùå ÌåÄ ÏàúÏúÑ Î∞è ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return []
    
    def analyze_results(self, question: str, data: list) -> str:
        """Ï°∞Ìöå Í≤∞Í≥ºÎ•º Î∂ÑÏÑùÌï¥ÏÑú ÎãµÎ≥Ä ÏÉùÏÑ±"""
        try:
            print(f"üîç analyze_results Ìò∏Ï∂ú - Îç∞Ïù¥ÌÑ∞ Í∞úÏàò: {len(data) if data else 0}Í∞ú")
            
            # Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Í∞í Î°úÍ∑∏ Ï∂úÎ†•
            if data:
                print(f"üìä Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞ ÎÇ¥Ïö©:")
                for i, item in enumerate(data[:3]):  # ÏµúÎåÄ 3Í∞úÎßå Ï∂úÎ†•
                    print(f"  [{i+1}] {item}")
                if len(data) > 3:
                    print(f"  ... Ïô∏ {len(data)-3}Í∞ú Îçî")
            
            if not data:
                print("‚ùå Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥ÏÑú ÏÉÅÌô©Î≥Ñ Ï†ÅÏ†àÌïú ÏùëÎãµ Î∞òÌôò")
                return self._get_no_data_message(question)
            
            # DB ÏóêÎü¨ Î©îÏãúÏßÄÍ∞Ä Ìè¨Ìï®Îêú Îç∞Ïù¥ÌÑ∞Ïù∏ÏßÄ ÌôïÏù∏
            if isinstance(data, list) and len(data) > 0:
                if isinstance(data[0], str) and data[0].startswith("DB_ERROR:"):
                    print("‚ùå DB ÏóêÎü¨ Í∞êÏßÄ - ÏóêÎü¨ Î©îÏãúÏßÄ Î∞òÌôò")
                    return data[0]
            
            # Îç∞Ïù¥ÌÑ∞Î•º Ïª®ÌÖçÏä§Ìä∏Î°ú Î≥ÄÌôò
            context = json.dumps(data, ensure_ascii=False, indent=2)
            
            # Î∂ÑÏÑù ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
            prompt = f"""
ÎãπÏã†ÏùÄ KBO Ï†ÑÎ¨∏ Î∂ÑÏÑùÍ∞ÄÏûÖÎãàÎã§. Îã§Ïùå Îç∞Ïù¥ÌÑ∞Î•º Î∞îÌÉïÏúºÎ°ú ÏÇ¨Ïö©ÏûêÏùò ÏßàÎ¨∏Ïóê ÎãµÎ≥ÄÌï¥Ï£ºÏÑ∏Ïöî.

ÏßàÎ¨∏: {question}

Îç∞Ïù¥ÌÑ∞ (Ïù¥ÎØ∏ Ï†ïÎ†¨ÎêòÏñ¥ ÏûàÏùå):
{context}

ÎãµÎ≥Ä Í∑úÏπô:
1. Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Î∞òÏúºÎ°ú Ï†ïÌôïÌïú ÎãµÎ≥ÄÏùÑ Ï†úÍ≥µÌïòÏÑ∏Ïöî
2. Íµ¨Ï≤¥Ï†ÅÏù∏ ÏàòÏπòÏôÄ ÏÑ†ÏàòÎ™ÖÏùÑ Ìè¨Ìï®ÌïòÏÑ∏Ïöî
3. Í∞ÑÍ≤∞ÌïòÍ≥† ÌïÑÏöîÌïú Ï†ïÎ≥¥Îßå Ï†úÍ≥µÌïòÏÑ∏Ïöî (Í≥ºÎèÑÌïú ÏÑ§Î™Ö Í∏àÏßÄ)
4. Ï§ÑÎ∞îÍøàÏùÑ ÌôúÏö©ÌïòÏó¨ ÏùΩÍ∏∞ ÏâΩÍ≤å ÏûëÏÑ±ÌïòÏÑ∏Ïöî
5. **ÎßàÌÅ¨Îã§Ïö¥ Î¨∏Î≤ï ÏÇ¨Ïö© Í∏àÏßÄ** (**, *, ~~, # Îì± ÏÇ¨Ïö©ÌïòÏßÄ ÎßàÏÑ∏Ïöî)
6. **Í≤ΩÍ∏∞ ÏòàÏ∏° ÏßàÎ¨∏Ïùò Í≤ΩÏö∞**: ÌåÄÎ≥Ñ ÏµúÍ∑º ÏÑ±Ï†ÅÍ≥º ÏÉÅÎåÄ Ï†ÑÏ†ÅÏùÑ Î∞îÌÉïÏúºÎ°ú Íµ¨Ï≤¥Ï†ÅÏù∏ ÏòàÏ∏°ÏùÑ Ï†úÍ≥µÌïòÏÑ∏Ïöî
7. **ÌôàÍµ¨Ïû• Ï†ïÎ≥¥**: Î°ØÎç∞Îäî ÏÇ¨ÏßÅ, ÌïúÌôîÎäî ÎåÄÏ†Ñ, ÏÇºÏÑ±ÏùÄ ÎåÄÍµ¨, SSGÎäî Î¨∏Ìïô, KTÎäî ÏàòÏõê, NCÎäî Ï∞ΩÏõê, KIAÎäî Í¥ëÏ£º, ÌÇ§ÏõÄÏùÄ Í≥†Ï≤ô, ÎëêÏÇ∞/LGÎäî Ïû†Ïã§
8. ‚ö†Ô∏è Ï§ëÏöî: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Ï°∞ÌöåÎêú Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî
9. ‚ö†Ô∏è CRITICAL: Îç∞Ïù¥ÌÑ∞Îäî Ïù¥ÎØ∏ Ï†ïÎ†¨ÎêòÏñ¥ ÏûàÏäµÎãàÎã§. Ï†àÎåÄÎ°ú ÏàúÏÑúÎ•º Î∞îÍæ∏ÏßÄ ÎßàÏÑ∏Ïöî!
10. ‚ö†Ô∏è ÏàúÏúÑ ÏßàÎ¨∏Ïùò Í≤ΩÏö∞: Îç∞Ïù¥ÌÑ∞Ïùò ÏàúÏÑúÎ•º Í∑∏ÎåÄÎ°ú Îî∞ÎùºÍ∞ÄÏÑ∏Ïöî (1Î≤àÏß∏ Îç∞Ïù¥ÌÑ∞ = 1ÏúÑ, 2Î≤àÏß∏ Îç∞Ïù¥ÌÑ∞ = 2ÏúÑ...)
11. ‚ö†Ô∏è ÌÉÄÏú®/ÌôàÎü∞ Îì± ÌÜµÍ≥Ñ ÏßàÎ¨∏Ïùò Í≤ΩÏö∞: Îç∞Ïù¥ÌÑ∞Ïùò ÏàúÏÑúÎ•º Ï†ïÌôïÌûà Ïú†ÏßÄÌïòÏó¨ ÎãµÎ≥ÄÌïòÏÑ∏Ïöî

ÎãµÎ≥Ä:"""
            
            response = self.llm.invoke(prompt)
            return response.content
            
        except Exception as e:
            print(f"‚ùå Í≤∞Í≥º Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return "DB_ERROR: Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
    
    def _get_no_data_message(self, question: str) -> str:
        """ÏßàÎ¨∏ Ïú†ÌòïÏóê Îî∞Î•∏ Ï†ÅÏ†àÌïú 'Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå' Î©îÏãúÏßÄ Î∞òÌôò"""
        question_lower = question.lower()
        
        # Í≤ΩÍ∏∞ ÏùºÏ†ï Í¥ÄÎ†® ÏßàÎ¨∏
        if any(keyword in question for keyword in ['Í≤ΩÍ∏∞', 'ÏùºÏ†ï', 'Ïä§ÏºÄÏ§Ñ', 'Ïò§Îäò', 'ÎÇ¥Ïùº', 'Ïñ¥Ï†ú']):
            if 'Ïò§Îäò' in question:
                return "Ïò§ÎäòÏùÄ Í≤ΩÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§. Îã§Î•∏ ÎÇ†ÏßúÏùò Í≤ΩÍ∏∞Î•º ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî! üòä"
            elif 'ÎÇ¥Ïùº' in question:
                return "ÎÇ¥ÏùºÏùÄ Í≤ΩÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§. Îã§Î•∏ ÎÇ†ÏßúÏùò Í≤ΩÍ∏∞Î•º ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî! üòä"
            else:
                return "Ìï¥Îãπ ÎÇ†ÏßúÏóêÎäî Í≤ΩÍ∏∞ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§. Îã§Î•∏ ÎÇ†ÏßúÎ•º Ï°∞ÌöåÌï¥Ï£ºÏÑ∏Ïöî! üòä"
        
        # ÏÑ†Ïàò Í¥ÄÎ†® ÏßàÎ¨∏
        elif any(keyword in question for keyword in ['ÏÑ†Ïàò', 'ÏÑ†Î∞ú', 'ÌÉÄÏûê', 'Ìà¨Ïàò', 'ÏÑ±Ï†Å', 'Í∏∞Î°ù', 'ÌÜµÍ≥Ñ']):
            # ÏÑ†ÏàòÎ™ÖÏù¥ Ìè¨Ìï®Îêú ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏
            import re
            player_name_pattern = r'[Í∞Ä-Ìû£]{2,4}(?= ÏÑ†Ïàò|Ïùò|Ïù¥|Í∞Ä|ÏùÄ|Îäî)'
            player_matches = re.findall(player_name_pattern, question)
            
            if player_matches:
                player_name = player_matches[0]
                return f"'{player_name}' ÏÑ†Ïàò Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÏÑ†Ïàò Ïù¥Î¶ÑÏùÑ Îã§Ïãú ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî! üòä"
            else:
                return "Ìï¥Îãπ Ï°∞Í±¥Ïóê ÎßûÎäî ÏÑ†Ïàò Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§. Îã§Î•∏ Ï°∞Í±¥ÏúºÎ°ú Í≤ÄÏÉâÌï¥Î≥¥ÏÑ∏Ïöî! üòä"
        
        # ÌåÄ ÏàúÏúÑ/ÌÜµÍ≥Ñ Í¥ÄÎ†® ÏßàÎ¨∏
        elif any(keyword in question for keyword in ['ÏàúÏúÑ', 'Îì±Ïàò', 'Ïö∞Ïäπ', 'Ìè¨Ïä§Ìä∏ÏãúÏ¶å', 'ÌîåÎ†àÏù¥Ïò§ÌîÑ']):
            return "Ìï¥Îãπ Ï°∞Í±¥Ïùò ÌåÄ ÏàúÏúÑ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Îã§Î•∏ Ï°∞Í±¥ÏúºÎ°ú Í≤ÄÏÉâÌï¥Î≥¥ÏÑ∏Ïöî! üòä"
        
        # Í≤ΩÍ∏∞ ÏòàÏ∏° Í¥ÄÎ†® ÏßàÎ¨∏
        elif any(keyword in question for keyword in ['Ïù¥Í∏∏', 'Ïßà Í≤É', 'ÏòàÏÉÅ', 'ÏäπÎ∂Ä', 'ÎàÑÍ∞Ä', 'Ïñ¥Îñ§ ÌåÄ', 'Í≤∞Í≥º', 'ÏòàÏ∏°', 'Ïù¥Í∏∏Í±∞Í∞ô', 'ÏßàÍ±∞Í∞ô', 'ÏäπÎ¶¨', 'Ìå®Î∞∞']):
            return "Í≤ΩÍ∏∞ ÏòàÏ∏°ÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. ÌåÄÎ™ÖÏùÑ Ìè¨Ìï®Ìï¥ÏÑú Îã§Ïãú ÏßàÎ¨∏Ìï¥Ï£ºÏÑ∏Ïöî! üòä"
        
        # ÏùºÎ∞òÏ†ÅÏù∏ Í≤ΩÏö∞
        else:
            return "Ìï¥Îãπ ÏßàÎ¨∏Ïóê ÎåÄÌïú Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Îã§Î•∏ ÏßàÎ¨∏ÏùÑ ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî! üòä"
    
    def process_question(self, question: str) -> str:
        """ÏßàÎ¨∏ÏùÑ RAG Í∏∞Î∞ò Text-to-SQLÎ°ú Ï≤òÎ¶¨"""
        try:
            print(f"üîç RAG Í∏∞Î∞ò Text-to-SQL Ï≤òÎ¶¨ ÏãúÏûë: {question}")
            print(f"üìã ÏßàÎ¨∏ Ï≤òÎ¶¨ ÌîåÎ°úÏö∞ Î∂ÑÏÑù ÏãúÏûë")
            
            # ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏
            is_daily_schedule = self._is_daily_schedule_question(question)
            print(f"üîç ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï ÏßàÎ¨∏ Ïó¨Î∂Ä: {is_daily_schedule}")
            
            if is_daily_schedule:
                print(f"üîç ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï ÏßàÎ¨∏ Í∞êÏßÄ: {question}")
                print(f"üìã ÌîåÎ°úÏö∞: _handle_daily_schedule_question() Ïã§Ìñâ")
                import asyncio
                import threading
                
                def run_in_thread():
                    # ÏÉàÎ°úÏö¥ Ïä§Î†àÎìúÏóêÏÑú ÏÉàÎ°úÏö¥ Ïù¥Î≤§Ìä∏ Î£®ÌîÑ Ïã§Ìñâ
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    try:
                        return loop.run_until_complete(self._handle_daily_schedule_question(question))
                    finally:
                        loop.close()
                
                try:
                    # Ïä§Î†àÎìúÏóêÏÑú ÎπÑÎèôÍ∏∞ Ìï®Ïàò Ïã§Ìñâ
                    result = [None]
                    thread = threading.Thread(target=lambda: result.__setitem__(0, run_in_thread()))
                    thread.start()
                    thread.join()
                    return result[0] if result[0] else "ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
                except Exception as e:
                    print(f"‚ùå ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
                    return "ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
            
            # ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Í≤∞Í≥º ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏
            elif self._is_daily_games_question(question):
                print(f"üîç ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Í≤∞Í≥º ÏßàÎ¨∏ Í∞êÏßÄ: {question}")
                print(f"üìã ÌîåÎ°úÏö∞: _handle_daily_games_analysis() Ïã§Ìñâ")
                import asyncio
                import threading
                
                def run_in_thread():
                    # ÏÉàÎ°úÏö¥ Ïä§Î†àÎìúÏóêÏÑú ÏÉàÎ°úÏö¥ Ïù¥Î≤§Ìä∏ Î£®ÌîÑ Ïã§Ìñâ
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    try:
                        return loop.run_until_complete(self._handle_daily_games_analysis(question))
                    finally:
                        loop.close()
                
                try:
                    # Ïä§Î†àÎìúÏóêÏÑú ÎπÑÎèôÍ∏∞ Ìï®Ïàò Ïã§Ìñâ
                    result = [None]
                    thread = threading.Thread(target=lambda: result.__setitem__(0, run_in_thread()))
                    thread.start()
                    thread.join()
                    return result[0] if result[0] else "ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
                except Exception as e:
                    print(f"‚ùå ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
                    return "ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
            
            # ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏
            elif self._is_future_game_info_question(question):
                print(f"üîç ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÏßàÎ¨∏ Í∞êÏßÄ: {question}")
                print(f"üìã ÌîåÎ°úÏö∞: _handle_future_game_info() Ïã§Ìñâ")
                return self._handle_future_game_info(question)
            
            # Í≤ΩÍ∏∞ ÏòàÏ∏° ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏
            elif self._is_game_prediction_question(question):
                print(f"üîç Í≤ΩÍ∏∞ ÏòàÏ∏° ÏßàÎ¨∏ Í∞êÏßÄ: {question}")
                print(f"üìã ÌîåÎ°úÏö∞: _analyze_game_prediction() Ïã§Ìñâ")
                return self._analyze_game_prediction([], question)
            
            # Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏
            elif self._is_game_analysis_question(question):
                print(f"üîç Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏßàÎ¨∏ Í∞êÏßÄ: {question}")
                print(f"üìã ÌîåÎ°úÏö∞: _handle_game_analysis_question() Ïã§Ìñâ")
                import asyncio
                import threading
                
                def run_in_thread():
                    # ÏÉàÎ°úÏö¥ Ïä§Î†àÎìúÏóêÏÑú ÏÉàÎ°úÏö¥ Ïù¥Î≤§Ìä∏ Î£®ÌîÑ Ïã§Ìñâ
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    try:
                        return loop.run_until_complete(self._handle_game_analysis_question(question))
                    finally:
                        loop.close()
                
                try:
                    # Ïä§Î†àÎìúÏóêÏÑú ÎπÑÎèôÍ∏∞ Ìï®Ïàò Ïã§Ìñâ
                    result = [None]
                    thread = threading.Thread(target=lambda: result.__setitem__(0, run_in_thread()))
                    thread.start()
                    thread.join()
                    return result[0] if result[0] else "Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
                except Exception as e:
                    print(f"‚ùå ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
                    return "Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
            
            # RAG ÏãúÏä§ÌÖúÏúºÎ°ú Ï≤òÎ¶¨
            print(f"üìã ÌîåÎ°úÏö∞: RAG ÏãúÏä§ÌÖú (generate_sql -> execute_sql -> analyze_results) Ïã§Ìñâ")
            
            # SQL ÏÉùÏÑ±
            sql = self.generate_sql(question)
            if not sql:
                print(f"‚ùå SQL ÏÉùÏÑ± Ïã§Ìå®")
                return "SQL ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§."
            
            # SQL Ïã§Ìñâ
            data = self.execute_sql(sql, question)
            
            # Í≤∞Í≥º Î∂ÑÏÑù
            answer = self.analyze_results(question, data)
            
            print(f"‚úÖ RAG Í∏∞Î∞ò Text-to-SQL Ï≤òÎ¶¨ ÏôÑÎ£å")
            return answer
            
        except Exception as e:
            print(f"‚ùå RAG Í∏∞Î∞ò Text-to-SQL Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
            return f"Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _is_future_game_info_question(self, question: str) -> bool:
        """ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÏßàÎ¨∏Ïù∏ÏßÄ ÌåêÎã®"""
        question_lower = question.lower()
        
        # ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Í¥ÄÎ†® ÌÇ§ÏõåÎìúÎì§
        future_info_keywords = [
            'ÏÑ†Î∞úÌà¨Ïàò', 'ÏÑ†Î∞ú', 'Ìà¨Ïàò', 'ÎùºÏù∏ÏóÖ', 'Ï∂úÏ†Ñ', 'ÏÑ†Ïàò', 'ÎàÑÍµ¨', 'Ïñ¥ÎîîÏÑú', 'Ïñ∏Ï†ú', 'Î™áÏãú', 
            'Í≤ΩÍ∏∞Ïû•', 'ÏÉÅÎåÄÌåÄ', 'ÎÇ¥Ïùº', 'Î™®Î†à', 'Îã§Ïùå', 'Ïù¥Î≤à Ï£º', 'Îã§Ïùå Ï£º', 'ÏïûÏúºÎ°ú', 'ÏòàÏ†ï', 
            'Í≤ΩÍ∏∞ Ï†ïÎ≥¥', 'Í≤ΩÍ∏∞ ÏÉÅÏÑ∏', 'Í≤ΩÍ∏∞ ÏÑ∏Î∂ÄÏÇ¨Ìï≠', 'Í≤ΩÍ∏∞ ÏãúÍ∞Ñ', 'Í≤ΩÍ∏∞ Ïû•ÏÜå', 'Ïñ¥Îäê ÌåÄ', 'Ïñ¥Îñ§ ÌåÄ'
        ]
        
        # ÏòàÏ∏° ÏßàÎ¨∏Í≥º Íµ¨Î∂ÑÌïòÍ∏∞ ÏúÑÌïú Ï†úÏô∏ ÌÇ§ÏõåÎìú
        prediction_keywords = ['Ïù¥Í∏∏', 'Ïßà Í≤É', 'ÏòàÏÉÅ', 'ÏäπÎ∂Ä', 'Í≤∞Í≥º', 'ÏòàÏ∏°', 'Ïù¥Í∏∏Í±∞Í∞ô', 'ÏßàÍ±∞Í∞ô', 'ÏäπÎ¶¨', 'Ìå®Î∞∞']
        
        # ÏòàÏ∏° ÌÇ§ÏõåÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥Í∞Ä ÏïÑÎãò
        if any(kw in question_lower for kw in prediction_keywords):
            return False
        
        # ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÌÇ§ÏõåÎìú Îß§Ïπ≠ ÌôïÏù∏
        matched_keywords = [kw for kw in future_info_keywords if kw in question_lower]
        if matched_keywords:
            print(f"  üîç ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÌÇ§ÏõåÎìú Îß§Ïπ≠: {matched_keywords}")
        else:
            print(f"  üîç ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÌÇ§ÏõåÎìú Îß§Ïπ≠ ÏóÜÏùå")
        
        return len(matched_keywords) > 0
    
    def _is_game_prediction_question(self, question: str) -> bool:
        """Í≤ΩÍ∏∞ ÏòàÏ∏° ÏßàÎ¨∏Ïù∏ÏßÄ ÌåêÎã®"""
        question_lower = question.lower()
        
        # Í≤ΩÍ∏∞ ÏòàÏ∏° Í¥ÄÎ†® ÌÇ§ÏõåÎìúÎì§
        prediction_keywords = [
            'Ïù¥Í∏∏', 'Ïßà Í≤É', 'ÏòàÏÉÅ', 'ÏäπÎ∂Ä', 'ÎàÑÍ∞Ä', 'Ïñ¥Îñ§ ÌåÄ', 'Í≤∞Í≥º', 'ÏòàÏ∏°', 'Ïù¥Í∏∏Í±∞Í∞ô', 'ÏßàÍ±∞Í∞ô', 
            'ÏäπÎ¶¨', 'Ìå®Î∞∞', 'ÎàÑÍ∞Ä Ïù¥Í∏∏', 'Ïñ¥Îñ§ ÌåÄÏù¥', 'ÏäπÎ∂Ä ÏòàÏÉÅ', 'Í≤ΩÍ∏∞ ÏòàÏÉÅ', 'Ïù¥Í∏∏Íπå', 'ÏßàÍπå', 
            'ÏäπÎ∂ÄÎäî', 'Í≤∞Í≥ºÎäî', 'Ïù¥Í∏∏ Í≤É Í∞ô', 'Ïßà Í≤É Í∞ô', 'ÏäπÎ∂Ä ÏòàÏÉÅ', 'Í≤ΩÍ∏∞ Í≤∞Í≥º ÏòàÏÉÅ', 
            'ÎàÑÍ∞Ä Ïù¥Í∏∏Íπå', 'Ïñ¥Îñ§ ÌåÄÏù¥ Ïù¥Í∏∏Íπå', 'Í≤ΩÍ∏∞ ÏäπÎ∂Ä ÏòàÏÉÅ', 'Í≤ΩÍ∏∞ Í≤∞Í≥º ÏòàÏ∏°'
        ]
        
        # ÌÇ§ÏõåÎìú Îß§Ïπ≠ ÌôïÏù∏
        matched_keywords = [kw for kw in prediction_keywords if kw in question_lower]
        if matched_keywords:
            print(f"  üîç Í≤ΩÍ∏∞ ÏòàÏ∏° ÌÇ§ÏõåÎìú Îß§Ïπ≠: {matched_keywords}")
        else:
            print(f"  üîç Í≤ΩÍ∏∞ ÏòàÏ∏° ÌÇ§ÏõåÎìú Îß§Ïπ≠ ÏóÜÏùå")
        
        return len(matched_keywords) > 0
    
    def _is_game_analysis_question(self, question: str) -> bool:
        """Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏßàÎ¨∏Ïù∏ÏßÄ ÌåêÎã® (RAG Í∏∞Î∞ò)"""
        try:
            # Î®ºÏ†Ä Í≤ΩÍ∏∞ ÏòàÏ∏° ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏ (ÏòàÏ∏° ÏßàÎ¨∏ÏùÄ Î∂ÑÏÑù ÏßàÎ¨∏ÏóêÏÑú Ï†úÏô∏)
            if self._is_game_prediction_question(question):
                return False
            
            # Ïä§ÌÇ§Îßà Îß§ÎãàÏ†ÄÎ•º ÌÜµÌï¥ Í¥ÄÎ†® Ï†ïÎ≥¥ Í≤ÄÏÉâ
            relevant_schema = self.schema_manager.get_relevant_schema(question, top_k=3)
            
            # ÏßàÎ¨∏ Ïú†Ìòï ÌôïÏù∏
            question_types = relevant_schema.get("question_types", [])
            
            # Í≤ΩÍ∏∞ Î∂ÑÏÑù Í¥ÄÎ†® ÏßàÎ¨∏ Ïú†ÌòïÎì§
            game_analysis_types = [
                "game_analysis", "game_review", "game_summary", 
                "game_result", "game_detail", "game_record"
            ]
            
            # ÏßàÎ¨∏ Ïú†ÌòïÏóêÏÑú Í≤ΩÍ∏∞ Î∂ÑÏÑù Í¥ÄÎ†® ÌÇ§ÏõåÎìú ÌôïÏù∏
            for qtype_info in question_types:
                content = qtype_info.get("content", "").lower()
                if any(keyword in content for keyword in ["Í≤ΩÍ∏∞", "game", "Í≤∞Í≥º", "Î∂ÑÏÑù", "ÏöîÏïΩ", "Î¶¨Î∑∞"]):
                    # ÎÇ†Ïßú Ï†ïÎ≥¥ÎèÑ Ìï®Íªò ÏûàÎäîÏßÄ ÌôïÏù∏
                    if self._has_date_reference(question):
                        return True
            
            # ÏßÅÏ†ëÏ†ÅÏù∏ Í≤ΩÍ∏∞ Î∂ÑÏÑù ÌÇ§ÏõåÎìú ÌôïÏù∏ (ÏµúÏÜåÌïúÏùò ÌÇ§ÏõåÎìú)
            question_lower = question.lower()
            direct_keywords = ["Í≤ΩÍ∏∞ Î∂ÑÏÑù", "Í≤ΩÍ∏∞ Í≤∞Í≥º", "Í≤ΩÍ∏∞ ÏöîÏïΩ", "Í≤ΩÍ∏∞ Î¶¨Î∑∞"]
            
            if any(keyword in question_lower for keyword in direct_keywords):
                return True
            
            # ÎÇ†Ïßú + Í≤ΩÍ∏∞ Í¥ÄÎ†® ÏßàÎ¨∏Ïù∏ÏßÄ ÌôïÏù∏
            if self._has_date_reference(question) and self._has_game_reference(question):
                return True
                
            return False
            
        except Exception as e:
            print(f"‚ùå Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏßàÎ¨∏ ÌåêÎã® Ïò§Î•ò: {e}")
            return False
    
    def _has_date_reference(self, question: str) -> bool:
        """ÎÇ†Ïßú Ï∞∏Ï°∞Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏"""
        # Íµ¨Ï≤¥Ï†Å ÎÇ†Ïßú Ìå®ÌÑ¥
        specific_date_patterns = [
            r'\d{4}ÎÖÑ\s*\d{1,2}Ïõî\s*\d{1,2}Ïùº',
            r'\d{4}-\d{1,2}-\d{1,2}',
            r'\d{1,2}/\d{1,2}',
            r'\d{1,2}Ïõî\s*\d{1,2}Ïùº'
        ]
        
        # ÏÉÅÎåÄÏ†Å ÎÇ†Ïßú Ìå®ÌÑ¥
        relative_date_patterns = [
            'Ïñ¥Ï†ú', 'Ïò§Îäò', 'ÎÇ¥Ïùº', 'ÏµúÍ∑º', 'ÏßÄÎÇú', 'Ïù¥Î≤à', 'Ï†ÄÎ≤à'
        ]
        
        has_specific_date = any(re.search(pattern, question) for pattern in specific_date_patterns)
        has_relative_date = any(pattern in question.lower() for pattern in relative_date_patterns)
        
        return has_specific_date or has_relative_date
    
    def _has_game_reference(self, question: str) -> bool:
        """Í≤ΩÍ∏∞ Í¥ÄÎ†® Ï∞∏Ï°∞Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏"""
        question_lower = question.lower()
        game_keywords = [
            'Í≤ΩÍ∏∞', 'Í≤åÏûÑ', 'ÏäπÎ∂Ä', 'Í≤∞Í≥º', 'Ïä§ÏΩîÏñ¥', 'Ï†êÏàò',
            'ÏäπÎ¶¨', 'Ìå®Î∞∞', 'Î¨¥ÏäπÎ∂Ä', 'Ïñ¥Îï†Ïñ¥', 'Ïñ¥Îï†ÎÇò', 'Ïñ¥ÎñªÍ≤å'
        ]
        
        return any(keyword in question_lower for keyword in game_keywords)
    
    def _is_daily_games_question(self, question: str) -> bool:
        """ÌïòÎ£®Ïπò Î™®Îì† Í≤ΩÍ∏∞ Í≤∞Í≥ºÎ•º ÏöîÏ≤≠ÌïòÎäî ÏßàÎ¨∏Ïù∏ÏßÄ ÌåêÎã®"""
        question_lower = question.lower()
        
        # Í≤ΩÍ∏∞ Í≤∞Í≥º Í¥ÄÎ†® ÌÇ§ÏõåÎìúÎì§ (Í≥ºÍ±∞ Í≤ΩÍ∏∞ Í≤∞Í≥º)
        result_keywords = [
            'Í≤ΩÍ∏∞ Í≤∞Í≥º', 'Í≤ΩÍ∏∞Îì§', 'Î™®Îì† Í≤ΩÍ∏∞', 'Ï†ÑÏ≤¥ Í≤ΩÍ∏∞', 'Í∑∏ÎÇ† Í≤ΩÍ∏∞',
            'Í≤ΩÍ∏∞ ÌòÑÌô©', 'Í≤ΩÍ∏∞ ÏÉÅÌô©', 'Ïò§ÎäòÏùò Í≤ΩÍ∏∞', 'Ïñ¥Ï†úÏùò Í≤ΩÍ∏∞', 
            'Í≤ΩÍ∏∞ ÏöîÏïΩ', 'Ïñ¥Îï†Ïñ¥', 'Ïñ¥Îï†ÎÇò', 'Ïñ¥ÎñªÍ≤å Îêê', 'Î∂ÑÏÑù'
        ]
        
        # Í≤ΩÍ∏∞ ÏùºÏ†ï Í¥ÄÎ†® ÌÇ§ÏõåÎìúÎì§ (ÎØ∏Îûò Í≤ΩÍ∏∞ ÏùºÏ†ï)
        schedule_keywords = [
            'Í≤ΩÍ∏∞ ÏùºÏ†ï', 'ÏùºÏ†ï', 'Ïä§ÏºÄÏ§Ñ', 'ÏòàÏ†ï', 'ÏïûÏúºÎ°ú', 'Îã§Ïùå', 'ÎÇ¥ÏùºÏùò Í≤ΩÍ∏∞'
        ]
        
        # ÌäπÏ†ï ÌåÄÏù¥ Ïñ∏Í∏âÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
        team_keywords = [
            'ÌïúÌôî', 'ÎëêÏÇ∞', 'KIA', 'ÌÇ§ÏõÄ', 'Î°ØÎç∞', 'ÏÇºÏÑ±', 'SSG', 'KT', 'NC', 'LG',
            'Ïù¥Í∏ÄÏä§', 'Î≤†Ïñ¥Ïä§', 'ÌÉÄÏù¥Í±∞Ï¶à', 'ÌûàÏñ¥Î°úÏ¶à', 'ÏûêÏù¥Ïñ∏Ï∏†', 'ÎùºÏù¥Ïò®Ï¶à',
            'ÎûúÎçîÏä§', 'ÏúÑÏ¶à', 'Îã§Ïù¥ÎÖ∏Ïä§', 'Ìä∏ÏúàÏä§'
        ]
        
        has_result_keyword = any(keyword in question_lower for keyword in result_keywords)
        has_schedule_keyword = any(keyword in question_lower for keyword in schedule_keywords)
        has_team_keyword = any(keyword in question_lower for keyword in team_keywords)
        
        # Í≤ΩÍ∏∞ Í≤∞Í≥º ÌÇ§ÏõåÎìúÍ∞Ä ÏûàÍ≥†, ÏùºÏ†ï ÌÇ§ÏõåÎìúÍ∞Ä ÏóÜÏúºÎ©∞, ÌäπÏ†ï ÌåÄÏù¥ Ïñ∏Í∏âÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
        return has_result_keyword and not has_schedule_keyword and not has_team_keyword
    
    def _is_daily_schedule_question(self, question: str) -> bool:
        """ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ïÏùÑ ÏöîÏ≤≠ÌïòÎäî ÏßàÎ¨∏Ïù∏ÏßÄ ÌåêÎã®"""
        question_lower = question.lower()
        
        # "Îã§Ïùå Í≤ΩÍ∏∞" ÏßàÎ¨∏ÏùÄ Ï†úÏô∏ (RAG ÏãúÏä§ÌÖúÏóêÏÑú Ï≤òÎ¶¨)
        if 'Îã§Ïùå Í≤ΩÍ∏∞' in question_lower:
            print(f"  üîç 'Îã§Ïùå Í≤ΩÍ∏∞' ÌÇ§ÏõåÎìú Í∞êÏßÄ - RAG ÏãúÏä§ÌÖúÏúºÎ°ú Ï†ÑÎã¨")
            return False
        
        # Í≤ΩÍ∏∞ ÏùºÏ†ï Í¥ÄÎ†® ÌÇ§ÏõåÎìúÎì§
        schedule_keywords = [
            'Í≤ΩÍ∏∞ ÏùºÏ†ï', 'ÏùºÏ†ï', 'Ïä§ÏºÄÏ§Ñ', 'ÏòàÏ†ï', 'ÏïûÏúºÎ°ú'
        ]
        
        # ÌÇ§ÏõåÎìú Îß§Ïπ≠ ÌôïÏù∏
        matched_keywords = [kw for kw in schedule_keywords if kw in question_lower]
        if matched_keywords:
            print(f"  üîç ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï ÌÇ§ÏõåÎìú Îß§Ïπ≠: {matched_keywords}")
        else:
            print(f"  üîç ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï ÌÇ§ÏõåÎìú Îß§Ïπ≠ ÏóÜÏùå")
        
        # ÌäπÏ†ï ÌåÄÏù¥ Ïñ∏Í∏âÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
        team_keywords = [
            'ÌïúÌôî', 'ÎëêÏÇ∞', 'KIA', 'ÌÇ§ÏõÄ', 'Î°ØÎç∞', 'ÏÇºÏÑ±', 'SSG', 'KT', 'NC', 'LG',
            'Ïù¥Í∏ÄÏä§', 'Î≤†Ïñ¥Ïä§', 'ÌÉÄÏù¥Í±∞Ï¶à', 'ÌûàÏñ¥Î°úÏ¶à', 'ÏûêÏù¥Ïñ∏Ï∏†', 'ÎùºÏù¥Ïò®Ï¶à',
            'ÎûúÎçîÏä§', 'ÏúÑÏ¶à', 'Îã§Ïù¥ÎÖ∏Ïä§', 'Ìä∏ÏúàÏä§'
        ]
        
        has_schedule_keyword = any(keyword in question_lower for keyword in schedule_keywords)
        has_team_keyword = any(keyword in question_lower for keyword in team_keywords)
        
        # ÏùºÏ†ï ÌÇ§ÏõåÎìúÍ∞Ä ÏûàÍ≥† ÌäπÏ†ï ÌåÄÏù¥ Ïñ∏Í∏âÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
        return has_schedule_keyword and not has_team_keyword
    
    async def _handle_daily_schedule_question(self, question: str) -> str:
        """ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï Ï≤òÎ¶¨"""
        try:
            print(f"üîç ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï ÏßàÎ¨∏ Ï≤òÎ¶¨ ÏãúÏûë: {question}")
            
            # ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï Ï°∞Ìöå
            daily_games = await self._find_daily_games_via_sql(question)
            
            if not daily_games:
                return "Ìï¥Îãπ ÎÇ†ÏßúÏùò Í≤ΩÍ∏∞ ÏùºÏ†ïÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            print(f"üîç Ï°∞ÌöåÎêú Í≤ΩÍ∏∞ ÏùºÏ†ï Ïàò: {len(daily_games)}Í∞ú")
            
            # Í≤ΩÍ∏∞ ÏùºÏ†ï ÏöîÏïΩ ÏÉùÏÑ±
            schedule_summary = self._generate_daily_schedule_summary(daily_games)
            
            print(f"‚úÖ ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï Ï≤òÎ¶¨ ÏôÑÎ£å: {len(daily_games)}Í∞ú Í≤ΩÍ∏∞")
            return schedule_summary
                
        except Exception as e:
            print(f"‚ùå ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞ ÏùºÏ†ï Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _generate_daily_schedule_summary(self, daily_games: list) -> str:
        """ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ ÏùºÏ†ï ÏöîÏïΩ ÏÉùÏÑ±"""
        try:
            if not daily_games:
                return "Í≤ΩÍ∏∞ ÏùºÏ†ïÏù¥ ÏóÜÏäµÎãàÎã§."
            
            # Ï≤´ Î≤àÏß∏ Í≤ΩÍ∏∞Ïùò ÎÇ†Ïßú ÏÇ¨Ïö©
            first_game_date = daily_games[0].get('game_date', '')
            if first_game_date and len(first_game_date) >= 10:
                formatted_date = f"{first_game_date[:4]}ÎÖÑ {first_game_date[5:7]}Ïõî {first_game_date[8:10]}Ïùº"
            else:
                formatted_date = first_game_date
            
            # Ï†ÑÏ≤¥ ÏùºÏ†ï ÏãúÏûë
            summary = f"üìÖ {formatted_date} KBO Í≤ΩÍ∏∞ ÏùºÏ†ï ({len(daily_games)}Í≤ΩÍ∏∞)\n"
            summary += "=" * 50 + "\n\n"
            
            # Í∞Å Í≤ΩÍ∏∞ ÏùºÏ†ï Ï∂îÍ∞Ä
            for i, game in enumerate(daily_games, 1):
                home_team = game.get('home_team_name', '')
                away_team = game.get('away_team_name', '')
                stadium = game.get('stadium', '')
                game_time = game.get('game_date_time', '')
                status_code = game.get('status_code', '')
                
                # ÏãúÍ∞Ñ Ìè¨Îß∑ÌåÖ
                if game_time and len(game_time) >= 16:
                    # 2025-09-22T18:30:00+00:00 -> 18:30
                    time_part = game_time[11:16]
                else:
                    time_part = "ÏãúÍ∞Ñ ÎØ∏Ï†ï"
                
                summary += f"üèüÔ∏è Í≤ΩÍ∏∞ {i}: {away_team} vs {home_team}\n"
                summary += f"   üìç Í≤ΩÍ∏∞Ïû•: {stadium}\n"
                summary += f"   ‚è∞ Í≤ΩÍ∏∞ÏãúÍ∞Ñ: {time_part}\n"
                
                # Í≤ΩÍ∏∞ ÏÉÅÌÉúÏóê Îî∞Î•∏ Ï∂îÍ∞Ä Ï†ïÎ≥¥
                if status_code == 'BEFORE':
                    summary += f"   üìã ÏÉÅÌÉú: ÏòàÏ†ï\n"
                elif status_code == 'LIVE':
                    summary += f"   üìã ÏÉÅÌÉú: ÏßÑÌñâÏ§ë\n"
                elif status_code == 'RESULT':
                    summary += f"   üìã ÏÉÅÌÉú: Ï¢ÖÎ£å\n"
                else:
                    summary += f"   üìã ÏÉÅÌÉú: {status_code}\n"
                
                summary += "\n"
            
            return summary
            
        except Exception as e:
            print(f"‚ùå ÌïòÎ£®Ïπò ÏùºÏ†ï ÏöîÏïΩ ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"{len(daily_games)}Í∞ú Í≤ΩÍ∏∞Í∞Ä ÏòàÏ†ïÎêòÏñ¥ ÏûàÏäµÎãàÎã§."
    
    async def _handle_daily_games_analysis(self, question: str) -> str:
        """ÌïòÎ£®Ïπò Î™®Îì† Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï≤òÎ¶¨"""
        try:
            print(f"üîç ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏßàÎ¨∏ Ï≤òÎ¶¨ ÏãúÏûë: {question}")
            
            # ÌïòÎ£®Ïπò Î™®Îì† Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå
            daily_games = await self._find_daily_games_via_sql(question)
            
            if not daily_games:
                return "Ìï¥Îãπ ÎÇ†ÏßúÏùò Í≤ΩÍ∏∞ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            print(f"üîç Ï°∞ÌöåÎêú Í≤ΩÍ∏∞ Ïàò: {len(daily_games)}Í∞ú")
            
            # Í∞Å Í≤ΩÍ∏∞Ïóê ÎåÄÌï¥ Î∂ÑÏÑù ÏàòÌñâ
            game_summaries = []
            
            for i, game_info in enumerate(daily_games):
                game_id = game_info.get('game_id')
                if not game_id:
                    continue
                
                print(f"üîç Í≤ΩÍ∏∞ {i+1}/{len(daily_games)} Î∂ÑÏÑù Ï§ë: {game_id}")
                
                try:
                    # Í≤ΩÍ∏∞ ÏÉÅÌÉú ÌôïÏù∏ (game_dataÏóêÏÑú statusCode Ï∂îÏ∂ú)
                    game_data = game_info.get('game_data', {})
                    status_code = game_data.get('statusCode', '0') if isinstance(game_data, dict) else '0'
                    print(f"üîç Í≤ΩÍ∏∞ {i+1} ÏÉÅÌÉú ÏΩîÎìú: {status_code}")
                    
                    # Í≤ΩÍ∏∞ Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (Î™®Îì† Í≤ΩÍ∏∞Ïóê ÎåÄÌï¥ API Ìò∏Ï∂úÌïòÏó¨ Ïã§Ï†ú ÏÉÅÌÉú ÌôïÏù∏)
                    record_data = await game_record_service.get_game_record(game_id)
                    print(f"üîç Í≤ΩÍ∏∞ {i+1} API Îç∞Ïù¥ÌÑ∞ ÏàòÏã†: {record_data is not None}")
                    
                    # APIÏóêÏÑú Î∞õÏùÄ Ïã§Ï†ú ÏÉÅÌÉú ÌôïÏù∏
                    actual_status = "ÏòàÏ†ï"  # Í∏∞Î≥∏Í∞í
                    if record_data and isinstance(record_data, dict):
                        result = record_data.get("result", {})
                        if result and result.get("recordData"):
                            # recordDataÍ∞Ä ÏûàÏúºÎ©¥ Í≤ΩÍ∏∞Í∞Ä ÏßÑÌñâÎêòÏóàÍ±∞ÎÇò Ï¢ÖÎ£åÎê®
                            actual_status = "ÏßÑÌñâÏôÑÎ£å"
                        else:
                            # recordDataÍ∞Ä nullÏù¥Î©¥ ÏòàÏ†ï
                            actual_status = "ÏòàÏ†ï"
                    
                    print(f"üîç Í≤ΩÍ∏∞ {i+1} Ïã§Ï†ú ÏÉÅÌÉú: {actual_status}")
                    
                    if record_data and actual_status == "ÏßÑÌñâÏôÑÎ£å":
                        # Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù (Ïã§Ï†úÎ°ú ÏßÑÌñâÎêú Í≤ΩÍ∏∞Îßå)
                        analysis = game_record_service.analyze_game_record(record_data)
                        
                        # Î∂ÑÏÑù Í≤∞Í≥º ÌôïÏù∏
                        if "error" in analysis:
                            print(f"‚ö†Ô∏è Í≤ΩÍ∏∞ {game_id} Î∂ÑÏÑù Ïò§Î•ò: {analysis['error']}")
                            # Ïò§Î•òÍ∞Ä ÏûàÏñ¥ÎèÑ Í∏∞Î≥∏ Ï†ïÎ≥¥ÎùºÎèÑ Ï†úÍ≥µ
                            summary = self._generate_basic_game_summary(game_info)
                            game_summaries.append(summary)
                            continue
                        
                        # ÏûêÏó∞Ïñ¥ ÏöîÏïΩ ÏÉùÏÑ±
                        summary = game_record_service.generate_game_summary(analysis)
                        game_summaries.append(summary)
                    else:
                        # API Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÍ±∞ÎÇò Í≤ΩÍ∏∞Í∞Ä ÏòàÏ†ïÏù∏ Í≤ΩÏö∞ Í∏∞Î≥∏ Ï†ïÎ≥¥ Ï†úÍ≥µ
                        print(f"üîç Í≤ΩÍ∏∞ {i+1} API Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå ÎòêÎäî ÏòàÏ†ï - Í∏∞Î≥∏ Ï†ïÎ≥¥Î°ú ÏöîÏïΩ ÏÉùÏÑ±")
                        summary = self._generate_basic_game_summary(game_info)
                        game_summaries.append(summary)
                    
                except Exception as e:
                    print(f"‚ùå Í≤ΩÍ∏∞ {game_id} Î∂ÑÏÑù Ïò§Î•ò: {e}")
                    # Ïò§Î•ò Î∞úÏÉù Ïãú Í∏∞Î≥∏ Ï†ïÎ≥¥ÎùºÎèÑ Ï†úÍ≥µ
                    summary = self._generate_basic_game_summary(game_info)
                    game_summaries.append(summary)
            
            # Ï†ÑÏ≤¥ ÏöîÏïΩ ÏÉùÏÑ±
            if game_summaries:
                final_summary = self._generate_daily_summary(daily_games, game_summaries)
                print(f"‚úÖ ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏôÑÎ£å: {len(daily_games)}Í∞ú Í≤ΩÍ∏∞")
                return final_summary
            else:
                return "Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
                
        except Exception as e:
            print(f"‚ùå ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _generate_basic_game_summary(self, game_info: dict) -> str:
        """Í∏∞Î≥∏ Í≤ΩÍ∏∞ Ï†ïÎ≥¥Î°ú ÏöîÏïΩ ÏÉùÏÑ±"""
        try:
            game_date = game_info.get('game_date', '')
            home_team = game_info.get('home_team_name', '')
            away_team = game_info.get('away_team_name', '')
            stadium = game_info.get('stadium', '')
            home_score = game_info.get('home_team_score', 0)
            away_score = game_info.get('away_team_score', 0)
            winner = game_info.get('winner', '')
            game_time = game_info.get('time', '')
            
            # game_dataÏóêÏÑú statusCode Ï∂îÏ∂ú
            game_data = game_info.get('game_data', {})
            status_code = game_data.get('statusCode', '0') if isinstance(game_data, dict) else '0'
            
            # ÎÇ†Ïßú Ìè¨Îß∑ÌåÖ
            if game_date and len(game_date) >= 10:
                formatted_date = f"{game_date[:4]}ÎÖÑ {game_date[5:7]}Ïõî {game_date[8:10]}Ïùº"
            else:
                formatted_date = game_date
            
            # Í∏∞Î≥∏ ÏöîÏïΩ
            summary = f"üìÖ {formatted_date} {stadium}ÏóêÏÑú Ïó¥Î¶∞ {away_team} vs {home_team} Í≤ΩÍ∏∞\n"
            
            # Í≤ΩÍ∏∞ ÏÉÅÌÉúÏóê Îî∞Î•∏ Ï≤òÎ¶¨ (statusCode Í∏∞Î∞ò)
            if status_code == '0':
                # Í≤ΩÍ∏∞ ÏòàÏ†ïÏù∏ Í≤ΩÏö∞
                if game_time:
                    summary += f"‚è∞ Í≤ΩÍ∏∞ ÏãúÍ∞Ñ: {game_time}\n"
                summary += f"üìã Í≤ΩÍ∏∞Í∞Ä ÏòàÏ†ïÎêòÏñ¥ ÏûàÏäµÎãàÎã§.\n"
                summary += f"üèüÔ∏è Í≤ΩÍ∏∞Ïû•: {stadium}\n"
                summary += f"‚öæ {away_team} vs {home_team}Ïùò Í≤ΩÍ∏∞Î•º Í∏∞ÎåÄÌï¥Ï£ºÏÑ∏Ïöî!"
                
            elif status_code == '2':
                # Í≤ΩÍ∏∞ ÏßÑÌñâ Ï§ëÏù∏ Í≤ΩÏö∞
                summary += f"üî• ÌòÑÏû¨ Í≤ΩÍ∏∞Í∞Ä ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§!\n"
                if home_score > 0 or away_score > 0:
                    summary += f"üìä ÌòÑÏû¨ Ï†êÏàò: {away_team} {away_score} - {home_score} {home_team}\n"
                summary += f"‚öæ Ïã§ÏãúÍ∞Ñ Í≤ΩÍ∏∞ ÏÉÅÌô©ÏùÑ ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî!"
                
            elif status_code == '4':
                # Í≤ΩÍ∏∞ Ï¢ÖÎ£åÎêú Í≤ΩÏö∞
                if winner == 'HOME':
                    summary += f"üèÜ {home_team} {home_score} - {away_score} {away_team}Î°ú ÏäπÎ¶¨"
                elif winner == 'AWAY':
                    summary += f"üèÜ {away_team} {away_score} - {home_score} {home_team}Î°ú ÏäπÎ¶¨"
                else:
                    summary += f"üèÜ {away_team} {away_score} - {home_score} {home_team}"
                
                summary += f"\n‚öæ Í≤ΩÍ∏∞ ÏÉÅÌÉú: Ï¢ÖÎ£å"
                    
            else:
                # Í∏∞ÌÉÄ ÏÉÅÌÉú
                if home_score > 0 or away_score > 0:
                    summary += f"üìä Ï†êÏàò: {away_team} {away_score} - {home_score} {home_team}\n"
                summary += f"üìã Í≤ΩÍ∏∞ Ï†ïÎ≥¥Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî. (ÏÉÅÌÉúÏΩîÎìú: {status_code})"
            
            return summary
            
        except Exception as e:
            print(f"‚ùå Í∏∞Î≥∏ Í≤ΩÍ∏∞ ÏöîÏïΩ ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞ Ï†ïÎ≥¥: {game_info.get('home_team_name', '')} vs {game_info.get('away_team_name', '')}"
    
    def _generate_daily_summary(self, daily_games: list, game_summaries: list) -> str:
        """ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Ï†ÑÏ≤¥ ÏöîÏïΩ ÏÉùÏÑ±"""
        try:
            if not daily_games:
                return "Í≤ΩÍ∏∞ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§."
            
            # Ï≤´ Î≤àÏß∏ Í≤ΩÍ∏∞Ïùò ÎÇ†Ïßú ÏÇ¨Ïö©
            first_game_date = daily_games[0].get('game_date', '')
            if first_game_date and len(first_game_date) >= 10:
                formatted_date = f"{first_game_date[:4]}ÎÖÑ {first_game_date[5:7]}Ïõî {first_game_date[8:10]}Ïùº"
            else:
                formatted_date = first_game_date
            
            # Ï†ÑÏ≤¥ ÏöîÏïΩ ÏãúÏûë
            summary = f"üìÖ {formatted_date} KBO Í≤ΩÍ∏∞ Í≤∞Í≥º ({len(daily_games)}Í≤ΩÍ∏∞)\n"
            summary += "=" * 50 + "\n\n"
            
            # Í∞Å Í≤ΩÍ∏∞ ÏöîÏïΩ Ï∂îÍ∞Ä
            for i, game_summary in enumerate(game_summaries, 1):
                summary += f"üèüÔ∏è Í≤ΩÍ∏∞ {i}:\n"
                summary += game_summary + "\n\n"
            
            # Í∞ÑÎã®Ìïú ÌÜµÍ≥Ñ Ï∂îÍ∞Ä
            home_wins = sum(1 for game in daily_games if game.get('winner') == 'HOME')
            away_wins = sum(1 for game in daily_games if game.get('winner') == 'AWAY')
            
            summary += f"üìä Í≤ΩÍ∏∞ Í≤∞Í≥º ÏöîÏïΩ:\n"
            summary += f"   ÌôàÌåÄ ÏäπÎ¶¨: {home_wins}Í≤ΩÍ∏∞\n"
            summary += f"   ÏõêÏ†ïÌåÄ ÏäπÎ¶¨: {away_wins}Í≤ΩÍ∏∞\n"
            
            return summary
            
        except Exception as e:
            print(f"‚ùå ÌïòÎ£®Ïπò ÏöîÏïΩ ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"{len(daily_games)}Í∞ú Í≤ΩÍ∏∞Í∞Ä ÏûàÏóàÏäµÎãàÎã§."
    
    async def _handle_game_analysis_question(self, question: str) -> str:
        """Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏßàÎ¨∏ Ï≤òÎ¶¨"""
        try:
            print(f"üîç Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏßàÎ¨∏ Ï≤òÎ¶¨ ÏãúÏûë: {question}")
            
            # SQLÏùÑ ÌÜµÌï¥ Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå
            game_info = await self._find_game_info_via_sql(question)
            
            if not game_info:
                return "Ìï¥Îãπ Ï°∞Í±¥Ïóê ÎßûÎäî Í≤ΩÍ∏∞ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            game_id = game_info.get('game_id')
            if not game_id:
                return "Í≤ΩÍ∏∞ IDÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            print(f"üîç Ï∞æÏùÄ Í≤åÏûÑ ID: {game_id}")
            
            # Í≤ΩÍ∏∞ ÏÉÅÌÉú ÌôïÏù∏ (game_dataÏóêÏÑú statusCode Ï∂îÏ∂ú)
            game_data = game_info.get('game_data', {})
            status_code = game_data.get('statusCode', '0') if isinstance(game_data, dict) else '0'
            print(f"üîç Í≤ΩÍ∏∞ ÏÉÅÌÉú ÏΩîÎìú: {status_code}")
            
            # Í≤ΩÍ∏∞ Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (Î™®Îì† Í≤ΩÍ∏∞Ïóê ÎåÄÌï¥ API Ìò∏Ï∂úÌïòÏó¨ Ïã§Ï†ú ÏÉÅÌÉú ÌôïÏù∏)
            record_data = await game_record_service.get_game_record(game_id)
            print(f"üîç API Îç∞Ïù¥ÌÑ∞ ÏàòÏã†: {record_data is not None}")
            
            # APIÏóêÏÑú Î∞õÏùÄ Ïã§Ï†ú ÏÉÅÌÉú ÌôïÏù∏
            actual_status = "ÏòàÏ†ï"  # Í∏∞Î≥∏Í∞í
            if record_data and isinstance(record_data, dict):
                result = record_data.get("result", {})
                if result and result.get("recordData"):
                    # recordDataÍ∞Ä ÏûàÏúºÎ©¥ Í≤ΩÍ∏∞Í∞Ä ÏßÑÌñâÎêòÏóàÍ±∞ÎÇò Ï¢ÖÎ£åÎê®
                    actual_status = "ÏßÑÌñâÏôÑÎ£å"
                else:
                    # recordDataÍ∞Ä nullÏù¥Î©¥ ÏòàÏ†ï
                    actual_status = "ÏòàÏ†ï"
            
            print(f"üîç Ïã§Ï†ú Í≤ΩÍ∏∞ ÏÉÅÌÉú: {actual_status}")
            
            if record_data and actual_status == "ÏßÑÌñâÏôÑÎ£å":
                # Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù (Ïã§Ï†úÎ°ú ÏßÑÌñâÎêú Í≤ΩÍ∏∞Îßå)
                analysis = game_record_service.analyze_game_record(record_data)
                
                # Î∂ÑÏÑù Í≤∞Í≥º ÌôïÏù∏
                if "error" in analysis:
                    print(f"‚ö†Ô∏è Í≤ΩÍ∏∞ Î∂ÑÏÑù Ïò§Î•ò: {analysis['error']}")
                    # Ïò§Î•òÍ∞Ä ÏûàÏñ¥ÎèÑ Í∏∞Î≥∏ Ï†ïÎ≥¥ÎùºÎèÑ Ï†úÍ≥µ
                    summary = self._generate_basic_game_summary(game_info)
                else:
                    # ÏûêÏó∞Ïñ¥ ÏöîÏïΩ ÏÉùÏÑ±
                    summary = game_record_service.generate_game_summary(analysis)
            else:
                # API Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÍ±∞ÎÇò Í≤ΩÍ∏∞Í∞Ä ÏòàÏ†ïÏù∏ Í≤ΩÏö∞ Í∏∞Î≥∏ Ï†ïÎ≥¥ Ï†úÍ≥µ
                print(f"üîç API Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå ÎòêÎäî ÏòàÏ†ï - Í∏∞Î≥∏ Ï†ïÎ≥¥Î°ú ÏöîÏïΩ ÏÉùÏÑ±")
                summary = self._generate_basic_game_summary(game_info)
            
            print(f"‚úÖ Í≤ΩÍ∏∞ Î∂ÑÏÑù ÏôÑÎ£å")
            return summary
            
        except Exception as e:
            print(f"‚ùå Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _extract_date_from_question(self, question: str) -> str:
        """ÏßàÎ¨∏ÏóêÏÑú ÎÇ†Ïßú Ï†ïÎ≥¥ Ï∂îÏ∂ú"""
        # YYYYÎÖÑ MMÏõî DDÏùº Ìå®ÌÑ¥
        pattern1 = r'(\d{4})ÎÖÑ\s*(\d{1,2})Ïõî\s*(\d{1,2})Ïùº'
        match1 = re.search(pattern1, question)
        if match1:
            year, month, day = match1.groups()
            return f"{year}{month.zfill(2)}{day.zfill(2)}"
        
        # YYYY-MM-DD Ìå®ÌÑ¥
        pattern2 = r'(\d{4})-(\d{1,2})-(\d{1,2})'
        match2 = re.search(pattern2, question)
        if match2:
            year, month, day = match2.groups()
            return f"{year}{month.zfill(2)}{day.zfill(2)}"
        
        # MM/DD Ìå®ÌÑ¥ (Ïò¨Ìï¥ Í∏∞Ï§Ä)
        pattern3 = r'(\d{1,2})/(\d{1,2})'
        match3 = re.search(pattern3, question)
        if match3:
            from datetime import datetime
            month, day = match3.groups()
            current_year = datetime.now().year
            return f"{current_year}{month.zfill(2)}{day.zfill(2)}"
        
        # MMÏõî DDÏùº Ìå®ÌÑ¥ (Ïò¨Ìï¥ Í∏∞Ï§Ä)
        pattern4 = r'(\d{1,2})Ïõî\s*(\d{1,2})Ïùº'
        match4 = re.search(pattern4, question)
        if match4:
            from datetime import datetime
            month, day = match4.groups()
            current_year = datetime.now().year
            return f"{current_year}{month.zfill(2)}{day.zfill(2)}"
        
        return None
    
    def _extract_team_from_question(self, question: str) -> str:
        """ÏßàÎ¨∏ÏóêÏÑú ÌåÄ Ï†ïÎ≥¥ Ï∂îÏ∂ú"""
        team_mappings = {
            'ÌïúÌôî': 'ÌïúÌôî', 'ÌïúÌôîÏù¥Í∏ÄÏä§': 'ÌïúÌôî', 'Ïù¥Í∏ÄÏä§': 'ÌïúÌôî',
            'ÎëêÏÇ∞': 'ÎëêÏÇ∞', 'ÎëêÏÇ∞Î≤†Ïñ¥Ïä§': 'ÎëêÏÇ∞', 'Î≤†Ïñ¥Ïä§': 'ÎëêÏÇ∞',
            'KIA': 'KIA', 'KIAÌÉÄÏù¥Í±∞Ï¶à': 'KIA', 'ÌÉÄÏù¥Í±∞Ï¶à': 'KIA',
            'ÌÇ§ÏõÄ': 'ÌÇ§ÏõÄ', 'ÌÇ§ÏõÄÌûàÏñ¥Î°úÏ¶à': 'ÌÇ§ÏõÄ', 'ÌûàÏñ¥Î°úÏ¶à': 'ÌÇ§ÏõÄ',
            'Î°ØÎç∞': 'Î°ØÎç∞', 'Î°ØÎç∞ÏûêÏù¥Ïñ∏Ï∏†': 'Î°ØÎç∞', 'ÏûêÏù¥Ïñ∏Ï∏†': 'Î°ØÎç∞',
            'ÏÇºÏÑ±': 'ÏÇºÏÑ±', 'ÏÇºÏÑ±ÎùºÏù¥Ïò®Ï¶à': 'ÏÇºÏÑ±', 'ÎùºÏù¥Ïò®Ï¶à': 'ÏÇºÏÑ±',
            'SSG': 'SSG', 'SSGÎûúÎçîÏä§': 'SSG', 'ÎûúÎçîÏä§': 'SSG',
            'KT': 'KT', 'KTÏúÑÏ¶à': 'KT', 'ÏúÑÏ¶à': 'KT',
            'NC': 'NC', 'NCÎã§Ïù¥ÎÖ∏Ïä§': 'NC', 'Îã§Ïù¥ÎÖ∏Ïä§': 'NC',
            'LG': 'LG', 'LGÌä∏ÏúàÏä§': 'LG', 'Ìä∏ÏúàÏä§': 'LG'
        }
        
        for team_keyword, team_name in team_mappings.items():
            if team_keyword in question:
                return team_name
        
        return None
    
    async def _find_game_info_via_sql(self, question: str) -> dict:
        """SQLÏùÑ ÌÜµÌï¥ Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        try:
            from datetime import datetime, timedelta
            
            # ÏßàÎ¨∏ÏóêÏÑú ÎÇ†ÏßúÏôÄ ÌåÄ Ï†ïÎ≥¥ Ï∂îÏ∂ú
            date_info = self._extract_date_from_question(question)
            team_info = self._extract_team_from_question(question)
            
            print(f"üîç Ï∂îÏ∂úÎêú ÎÇ†Ïßú: {date_info}")
            print(f"üîç Ï∂îÏ∂úÎêú ÌåÄ: {team_info}")
            
            # ÏÉÅÎåÄÏ†Å ÎÇ†Ïßú Ï≤òÎ¶¨
            if not date_info:
                date_info = self._extract_relative_date(question)
                print(f"üîç ÏÉÅÎåÄÏ†Å ÎÇ†Ïßú Ï∂îÏ∂ú Í≤∞Í≥º: {date_info}")
            
            # SQL ÏøºÎ¶¨ Íµ¨ÏÑ±
            query = self.supabase.supabase.table("game_schedule").select("*")
            
            # ÎÇ†Ïßú Ï°∞Í±¥ Ï∂îÍ∞Ä (ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå) - Ïã§Ï†ú Ïª¨ÎüºÎ™ÖÏùÄ game_date
            if date_info:
                # YYYYMMDD ÌòïÏãùÏùÑ YYYY-MM-DD ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
                if len(date_info) == 8:
                    formatted_date = f"{date_info[:4]}-{date_info[4:6]}-{date_info[6:8]}"
                    query = query.eq("game_date", formatted_date)
                else:
                    query = query.eq("game_date", date_info)
            
            # ÌåÄ Ï°∞Í±¥ Ï∂îÍ∞Ä
            if team_info:
                # ÌåÄ ÏΩîÎìú Îß§Ìïë
                team_code_mapping = {
                    'ÌïúÌôî': 'HH', 'ÎëêÏÇ∞': 'OB', 'KIA': 'HT', 'ÌÇ§ÏõÄ': 'WO',
                    'Î°ØÎç∞': 'LT', 'ÏÇºÏÑ±': 'SS', 'SSG': 'SK', 'KT': 'KT',
                    'NC': 'NC', 'LG': 'LG'
                }
                
                team_code = team_code_mapping.get(team_info, team_info)
                # Supabase OR Ï°∞Í±¥ÏùÑ Îëê Í∞úÏùò ÏøºÎ¶¨Î°ú Î∂ÑÎ¶¨ÌïòÏó¨ Ï≤òÎ¶¨
                # Î®ºÏ†Ä ÌôàÌåÄ Ï°∞Í±¥ÏúºÎ°ú Ï°∞Ìöå
                home_query = self.supabase.supabase.table("game_schedule").select("*")
                if date_info:
                    # YYYYMMDD ÌòïÏãùÏùÑ YYYY-MM-DD ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
                    if len(date_info) == 8:
                        formatted_date = f"{date_info[:4]}-{date_info[4:6]}-{date_info[6:8]}"
                        home_query = home_query.eq("game_date", formatted_date)
                    else:
                        home_query = home_query.eq("game_date", date_info)
                home_query = home_query.eq("home_team_code", team_code).order("game_date", desc=True).limit(1)
                home_result = home_query.execute()
                
                if home_result.data:
                    return home_result.data[0]
                
                # ÌôàÌåÄ Ï°∞Í±¥ÏóêÏÑú Í≤∞Í≥ºÍ∞Ä ÏóÜÏúºÎ©¥ ÏõêÏ†ïÌåÄ Ï°∞Í±¥ÏúºÎ°ú Ï°∞Ìöå
                away_query = self.supabase.supabase.table("game_schedule").select("*")
                if date_info:
                    # YYYYMMDD ÌòïÏãùÏùÑ YYYY-MM-DD ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
                    if len(date_info) == 8:
                        formatted_date = f"{date_info[:4]}-{date_info[4:6]}-{date_info[6:8]}"
                        away_query = away_query.eq("game_date", formatted_date)
                    else:
                        away_query = away_query.eq("game_date", date_info)
                away_query = away_query.eq("away_team_code", team_code).order("game_date", desc=True).limit(1)
                away_result = away_query.execute()
                
                if away_result.data:
                    return away_result.data[0]
                
                return None
            
            # ÏµúÏã† Í≤ΩÍ∏∞ Ïö∞ÏÑ† Ï†ïÎ†¨
            query = query.order("game_date", desc=True).limit(1)
            
            result = query.execute()
            
            if result.data and len(result.data) > 0:
                return result.data[0]
            
            # ÎÇ†Ïßú Ï†ïÎ≥¥Í∞Ä ÏóÜÎäî Í≤ΩÏö∞ ÏµúÍ∑º Í≤ΩÍ∏∞ Ï°∞Ìöå ÏãúÎèÑ
            if not date_info and team_info:
                print("üîç ÎÇ†Ïßú Ï†ïÎ≥¥Í∞Ä ÏóÜÏñ¥ÏÑú ÏµúÍ∑º Í≤ΩÍ∏∞ Ï°∞Ìöå ÏãúÎèÑ")
                return await self._find_recent_games_without_date(team_info)
            
            return None
            
        except Exception as e:
            print(f"‚ùå SQL Í∏∞Î∞ò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return None
    
    async def _find_daily_games_via_sql(self, question: str) -> list:
        """SQLÏùÑ ÌÜµÌï¥ ÌïòÎ£®Ïπò Î™®Îì† Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        try:
            from datetime import datetime, timedelta
            
            # ÏßàÎ¨∏ÏóêÏÑú ÎÇ†ÏßúÏôÄ ÌåÄ Ï†ïÎ≥¥ Ï∂îÏ∂ú
            date_info = self._extract_date_from_question(question)
            team_info = self._extract_team_from_question(question)
            
            print(f"üîç Ï∂îÏ∂úÎêú ÎÇ†Ïßú: {date_info}")
            print(f"üîç Ï∂îÏ∂úÎêú ÌåÄ: {team_info}")
            
            # ÏÉÅÎåÄÏ†Å ÎÇ†Ïßú Ï≤òÎ¶¨ (ÎÇ†ÏßúÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞)
            if not date_info:
                relative_date = self._extract_relative_date(question)
                if relative_date:
                    date_info = relative_date
                    print(f"üîç ÏÉÅÎåÄÏ†Å ÎÇ†Ïßú Ï∂îÏ∂ú Í≤∞Í≥º: {date_info}")
            
            # ÎÇ†ÏßúÍ∞Ä ÏóÜÏúºÎ©¥ ÏµúÍ∑º Í≤ΩÍ∏∞ ÎÇ†Ïßú Ï°∞Ìöå
            if not date_info:
                # Í∞ÄÏû• ÏµúÍ∑º Í≤ΩÍ∏∞ ÎÇ†Ïßú Ï°∞Ìöå
                recent_query = self.supabase.supabase.table("game_schedule").select("game_date").order("game_date", desc=True).limit(1)
                recent_result = recent_query.execute()
                if recent_result.data:
                    date_info = recent_result.data[0]['game_date']
                    print(f"üîç ÏµúÍ∑º Í≤ΩÍ∏∞ ÎÇ†Ïßú: {date_info}")
            
            if not date_info:
                print("‚ùå Ï°∞ÌöåÌï† ÎÇ†ÏßúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
                return []
            
            # SQL ÏøºÎ¶¨ Íµ¨ÏÑ± - Ìï¥Îãπ ÎÇ†ÏßúÏùò Î™®Îì† Í≤ΩÍ∏∞
            query = self.supabase.supabase.table("game_schedule").select("*")
            
            # ÎÇ†Ïßú Ï°∞Í±¥ Ï∂îÍ∞Ä - Ïã§Ï†ú Ïª¨ÎüºÎ™ÖÏùÄ game_date
            if len(date_info) == 8:  # YYYYMMDD ÌòïÏãù
                formatted_date = f"{date_info[:4]}-{date_info[4:6]}-{date_info[6:8]}"
                query = query.eq("game_date", formatted_date)
            else:  # YYYY-MM-DD ÌòïÏãù
                query = query.eq("game_date", date_info)
            
            # ÌåÄ Ï°∞Í±¥Ïù¥ ÏûàÎäî Í≤ΩÏö∞ ÌïÑÌÑ∞ÎßÅ
            if team_info:
                team_code_mapping = {
                    'ÌïúÌôî': 'HH', 'ÎëêÏÇ∞': 'OB', 'KIA': 'HT', 'ÌÇ§ÏõÄ': 'WO',
                    'Î°ØÎç∞': 'LT', 'ÏÇºÏÑ±': 'SS', 'SSG': 'SK', 'KT': 'KT',
                    'NC': 'NC', 'LG': 'LG'
                }
                team_code = team_code_mapping.get(team_info, team_info)
                
                # ÌôàÌåÄ ÎòêÎäî ÏõêÏ†ïÌåÄ Ï°∞Í±¥ÏúºÎ°ú ÌïÑÌÑ∞ÎßÅ - Îëê Í∞úÏùò ÏøºÎ¶¨Î°ú Î∂ÑÎ¶¨
                # Î®ºÏ†Ä ÌôàÌåÄ Ï°∞Í±¥ÏúºÎ°ú Ï°∞Ìöå
                home_query = self.supabase.supabase.table("game_schedule").select("*")
                if len(date_info) == 8:  # YYYYMMDD ÌòïÏãù
                    formatted_date = f"{date_info[:4]}-{date_info[4:6]}-{date_info[6:8]}"
                    home_query = home_query.eq("game_date", formatted_date)
                else:  # YYYY-MM-DD ÌòïÏãù
                    home_query = home_query.eq("game_date", date_info)
                home_query = home_query.eq("home_team_code", team_code).order("game_date_time")
                home_result = home_query.execute()
                
                # ÏõêÏ†ïÌåÄ Ï°∞Í±¥ÏúºÎ°ú Ï°∞Ìöå
                away_query = self.supabase.supabase.table("game_schedule").select("*")
                if len(date_info) == 8:  # YYYYMMDD ÌòïÏãù
                    formatted_date = f"{date_info[:4]}-{date_info[4:6]}-{date_info[6:8]}"
                    away_query = away_query.eq("game_date", formatted_date)
                else:  # YYYY-MM-DD ÌòïÏãù
                    away_query = away_query.eq("game_date", date_info)
                away_query = away_query.eq("away_team_code", team_code).order("game_date_time")
                away_result = away_query.execute()
                
                # Í≤∞Í≥º Ìï©ÏπòÍ∏∞
                all_games = []
                if home_result.data:
                    all_games.extend(home_result.data)
                if away_result.data:
                    all_games.extend(away_result.data)
                
                # Ï§ëÎ≥µ Ï†úÍ±∞ (game_id Í∏∞Ï§Ä)
                seen_ids = set()
                unique_games = []
                for game in all_games:
                    game_id = game.get('game_id')
                    if game_id and game_id not in seen_ids:
                        seen_ids.add(game_id)
                        unique_games.append(game)
                
                return unique_games
            
            # ÏãúÍ∞Ñ ÏàúÏúºÎ°ú Ï†ïÎ†¨
            result = query.order("game_date_time").execute()
            
            if result.data:
                print(f"‚úÖ {date_info} ÎÇ†Ïßú Í≤ΩÍ∏∞ {len(result.data)}Í∞ú Ï°∞Ìöå ÏÑ±Í≥µ")
                return result.data
            else:
                print(f"‚ùå {date_info} ÎÇ†ÏßúÏóê Í≤ΩÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå")
                return []
                
        except Exception as e:
            print(f"‚ùå ÌïòÎ£®Ïπò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return []
    
    def _extract_relative_date(self, question: str) -> str:
        """ÏßàÎ¨∏ÏóêÏÑú ÏÉÅÎåÄÏ†Å ÎÇ†Ïßú Ï∂îÏ∂ú (YYYY-MM-DD ÌòïÏãù)"""
        from datetime import datetime, timedelta
        
        question_lower = question.lower()
        
        if 'Ïñ¥Ï†ú' in question_lower:
            yesterday = datetime.now() - timedelta(days=1)
            return yesterday.strftime("%Y-%m-%d")
        elif 'Ïò§Îäò' in question_lower:
            today = datetime.now()
            return today.strftime("%Y-%m-%d")
        elif 'ÎÇ¥Ïùº' in question_lower:
            tomorrow = datetime.now() + timedelta(days=1)
            return tomorrow.strftime("%Y-%m-%d")
        elif 'ÏµúÍ∑º' in question_lower or 'ÏßÄÎÇú' in question_lower:
            # ÏµúÍ∑º 7Ïùº ÎÇ¥Ïùò Í≤ΩÍ∏∞ Ï§ë Í∞ÄÏû• ÏµúÍ∑º Í≤ΩÍ∏∞
            recent_date = datetime.now() - timedelta(days=1)
            return recent_date.strftime("%Y-%m-%d")
        
        return None
    
    async def _find_recent_games_without_date(self, team_info: str = None) -> dict:
        """ÎÇ†Ïßú Ï†ïÎ≥¥Í∞Ä ÏóÜÎäî Í≤ΩÏö∞ ÏµúÍ∑º Í≤ΩÍ∏∞ Ï°∞Ìöå"""
        try:
            query = self.supabase.supabase.table("game_schedule").select("*")
            
            # ÌåÄ Ï°∞Í±¥ Ï∂îÍ∞Ä
            if team_info:
                team_code_mapping = {
                    'ÌïúÌôî': 'HH', 'ÎëêÏÇ∞': 'OB', 'KIA': 'HT', 'ÌÇ§ÏõÄ': 'WO',
                    'Î°ØÎç∞': 'LT', 'ÏÇºÏÑ±': 'SS', 'SSG': 'SK', 'KT': 'KT',
                    'NC': 'NC', 'LG': 'LG'
                }
                
                team_code = team_code_mapping.get(team_info, team_info)
                # Supabase OR Ï°∞Í±¥ÏùÑ Îëê Í∞úÏùò ÏøºÎ¶¨Î°ú Î∂ÑÎ¶¨ÌïòÏó¨ Ï≤òÎ¶¨
                # Î®ºÏ†Ä ÌôàÌåÄ Ï°∞Í±¥ÏúºÎ°ú Ï°∞Ìöå
                home_query = self.supabase.supabase.table("game_schedule").select("*")
                home_query = home_query.eq("home_team_code", team_code).order("game_date", desc=True).limit(1)
                home_result = home_query.execute()
                
                if home_result.data:
                    return home_result.data[0]
                
                # ÌôàÌåÄ Ï°∞Í±¥ÏóêÏÑú Í≤∞Í≥ºÍ∞Ä ÏóÜÏúºÎ©¥ ÏõêÏ†ïÌåÄ Ï°∞Í±¥ÏúºÎ°ú Ï°∞Ìöå
                away_query = self.supabase.supabase.table("game_schedule").select("*")
                away_query = away_query.eq("away_team_code", team_code).order("game_date", desc=True).limit(1)
                away_result = away_query.execute()
                
                if away_result.data:
                    return away_result.data[0]
                
                return None
            
            # ÏµúÏã† Í≤ΩÍ∏∞ Ïö∞ÏÑ† Ï†ïÎ†¨ (ÎÇ†Ïßú ÎÇ¥Î¶ºÏ∞®Ïàú)
            query = query.order("game_date", desc=True).limit(1)
            
            result = query.execute()
            
            if result.data and len(result.data) > 0:
                return result.data[0]
            
            return None
            
        except Exception as e:
            print(f"‚ùå ÏµúÍ∑º Í≤ΩÍ∏∞ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return None
    
    def _analyze_game_prediction(self, data: list, question: str) -> str:
        """Í≤ΩÍ∏∞ ÏòàÏ∏° ÏßàÎ¨∏Ïóê ÎåÄÌïú ÏÉÅÎåÄÏ†ÑÏ†Å Í∏∞Î∞ò Î∂ÑÏÑù"""
        try:
            print(f"üîç Í≤ΩÍ∏∞ ÏòàÏ∏° Î∂ÑÏÑù ÏãúÏûë: {question}")
            
            # ÏßàÎ¨∏ÏóêÏÑú ÌåÄÎ™Ö Ï∂îÏ∂ú
            team_names = self._extract_team_names_from_question(question)
            
            # ÌåÄÎ™ÖÏù¥ Î™ÖÏãúÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞, ÎØ∏Îûò Í≤ΩÍ∏∞ ÌôïÏù∏
            if not team_names:
                print(f"üîç ÌåÄÎ™ÖÏù¥ Î™ÖÏãúÎêòÏßÄ ÏïäÏùå - ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå")
                future_games = self._get_future_games(question)
                if not future_games:
                    return "Ìï¥Îãπ ÎÇ†ÏßúÏóê Í≤ΩÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§. Îã§Î•∏ ÎÇ†ÏßúÏùò Í≤ΩÍ∏∞Î•º ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî! üòä"
                
                # ÎØ∏Îûò Í≤ΩÍ∏∞Îì§Ïóê ÎåÄÌïú ÏòàÏ∏° ÎãµÎ≥Ä ÏÉùÏÑ±
                return self._generate_future_games_prediction(future_games, question)
            
            # game_scheduleÏóêÏÑú Ìï¥Îãπ ÌåÄÏùò Îã§Ïùå Í≤ΩÍ∏∞ Ï°∞Ìöå
            next_game = self._get_next_game_for_teams(team_names)
            if not next_game:
                return f"{', '.join(team_names)}Ïùò Îã§Ïùå Í≤ΩÍ∏∞ ÏùºÏ†ïÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            # ÏÉÅÎåÄÌåÄ Ï†ïÎ≥¥ Ï∂îÏ∂ú
            home_team = next_game.get('home_team_name', '')
            away_team = next_game.get('away_team_name', '')
            game_date = next_game.get('game_date', '')
            stadium = next_game.get('stadium', '')
            
            # ÏÉÅÎåÄÏ†ÑÏ†Å Î∂ÑÏÑù
            prediction_analysis = self._analyze_head_to_head_stats(home_team, away_team)
            
            # ÌåÄÎ≥Ñ ÏµúÍ∑º ÏÑ±Ï†Å Î∂ÑÏÑù
            home_team_stats = self._get_team_recent_stats(home_team)
            away_team_stats = self._get_team_recent_stats(away_team)
            
            # ÏòàÏ∏° ÎãµÎ≥Ä ÏÉùÏÑ±
            prediction = self._generate_prediction_response(
                home_team, away_team, game_date, stadium, 
                prediction_analysis, home_team_stats, away_team_stats
            )
            
            return prediction
            
        except Exception as e:
            print(f"‚ùå Í≤ΩÍ∏∞ ÏòàÏ∏° Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞ ÏòàÏ∏° Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _get_future_games(self, question: str) -> list:
        """ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå (ÎÇ†Ïßú Ï∂îÏ∂ú Í∏∞Î∞ò)"""
        try:
            from datetime import datetime, timedelta
            import re
            
            # ÏßàÎ¨∏ÏóêÏÑú ÎÇ†Ïßú Ï†ïÎ≥¥ Ï∂îÏ∂ú
            target_date = self._extract_target_date(question)
            
            if not target_date:
                # ÎÇ†ÏßúÍ∞Ä Î™ÖÏãúÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞, Ïò§ÎäòÎ∂ÄÌÑ∞ ÏïûÏúºÎ°ú 7ÏùºÍ∞ÑÏùò Í≤ΩÍ∏∞ Ï°∞Ìöå
                today = datetime.now().strftime("%Y-%m-%d")
                future_date = (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d")
                print(f"üîç ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå: {today} ~ {future_date}")
                
                # SupabaseÏóêÏÑú ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå
                result = self.supabase.supabase.table("game_schedule").select("*").gte("game_date", today).lte("game_date", future_date).order("game_date").execute()
            else:
                print(f"üîç ÌäπÏ†ï ÎÇ†Ïßú Í≤ΩÍ∏∞ Ï°∞Ìöå: {target_date}")
                
                # SupabaseÏóêÏÑú ÌäπÏ†ï ÎÇ†Ïßú Í≤ΩÍ∏∞ Ï°∞Ìöå
                result = self.supabase.supabase.table("game_schedule").select("*").eq("game_date", target_date).execute()
            
            if result.data:
                print(f"‚úÖ Í≤ΩÍ∏∞ {len(result.data)}Í∞ú Î∞úÍ≤¨")
                return result.data
            else:
                print(f"‚ùå Í≤ΩÍ∏∞ ÏóÜÏùå")
                return []
                
        except Exception as e:
            print(f"‚ùå ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return []
    
    def _extract_target_date(self, question: str) -> str:
        """ÏßàÎ¨∏ÏóêÏÑú Î™©Ìëú ÎÇ†Ïßú Ï∂îÏ∂ú"""
        try:
            from datetime import datetime, timedelta
            import re
            
            question_lower = question.lower()
            today = datetime.now()
            
            # ÏÉÅÎåÄÏ†Å ÎÇ†Ïßú ÌëúÌòÑ Ï≤òÎ¶¨
            if "ÎÇ¥Ïùº" in question_lower or "tomorrow" in question_lower:
                return (today + timedelta(days=1)).strftime("%Y-%m-%d")
            elif "Î™®Î†à" in question_lower or "day after tomorrow" in question_lower:
                return (today + timedelta(days=2)).strftime("%Y-%m-%d")
            elif "Í∏ÄÌîº" in question_lower:
                return (today + timedelta(days=3)).strftime("%Y-%m-%d")
            elif "Îã§Ïùå Ï£º" in question_lower or "next week" in question_lower:
                return (today + timedelta(days=7)).strftime("%Y-%m-%d")
            elif "Ïù¥Î≤à Ï£º" in question_lower or "this week" in question_lower:
                # Ïù¥Î≤à Ï£º ÎÇ®ÏùÄ ÎÇ†Îì§
                return None  # ÌäπÏ†ï ÎÇ†ÏßúÍ∞Ä ÏïÑÎãàÎØÄÎ°ú None Î∞òÌôò
            elif "ÏïûÏúºÎ°ú" in question_lower or "ÏïûÏúºÎ°ú ÎÇ®ÏùÄ" in question_lower or "upcoming" in question_lower:
                return None  # ÏïûÏúºÎ°ú ÎÇ®ÏùÄ Î™®Îì† Í≤ΩÍ∏∞
            elif "Ïò§Îäò" in question_lower or "today" in question_lower:
                return today.strftime("%Y-%m-%d")
            
            # Íµ¨Ï≤¥Ï†ÅÏù∏ ÎÇ†Ïßú Ìå®ÌÑ¥ Ï∞æÍ∏∞ (YYYY-MM-DD, MM/DD, MMÏõî DDÏùº Îì±)
            date_patterns = [
                r'(\d{4})-(\d{1,2})-(\d{1,2})',  # 2025-09-25
                r'(\d{1,2})/(\d{1,2})',  # 9/25
                r'(\d{1,2})Ïõî\s*(\d{1,2})Ïùº',  # 9Ïõî 25Ïùº
                r'(\d{1,2})Ïùº',  # 25Ïùº (Ïù¥Î≤à Îã¨)
            ]
            
            for pattern in date_patterns:
                match = re.search(pattern, question)
                if match:
                    if pattern == r'(\d{4})-(\d{1,2})-(\d{1,2})':
                        year, month, day = match.groups()
                        return f"{year}-{month.zfill(2)}-{day.zfill(2)}"
                    elif pattern == r'(\d{1,2})/(\d{1,2})':
                        month, day = match.groups()
                        return f"{today.year}-{month.zfill(2)}-{day.zfill(2)}"
                    elif pattern == r'(\d{1,2})Ïõî\s*(\d{1,2})Ïùº':
                        month, day = match.groups()
                        return f"{today.year}-{month.zfill(2)}-{day.zfill(2)}"
                    elif pattern == r'(\d{1,2})Ïùº':
                        day = match.group(1)
                        return f"{today.year}-{today.month:02d}-{day.zfill(2)}"
            
            return None
            
        except Exception as e:
            print(f"‚ùå ÎÇ†Ïßú Ï∂îÏ∂ú Ïò§Î•ò: {e}")
            return None
    
    def _generate_future_games_prediction(self, games: list, question: str) -> str:
        """ÎØ∏Îûò Í≤ΩÍ∏∞Îì§Ïóê ÎåÄÌïú ÏòàÏ∏° ÎãµÎ≥Ä ÏÉùÏÑ±"""
        try:
            if not games:
                return "Ìï¥Îãπ ÎÇ†ÏßúÏóê Í≤ΩÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§."
            
            # ÏßàÎ¨∏ÏóêÏÑú ÎÇ†Ïßú Ï†ïÎ≥¥ Ï∂îÏ∂úÌïòÏó¨ Ï†úÎ™© ÏÉùÏÑ±
            date_title = self._get_date_title(question, games)
            
            predictions = []
            for game in games:
                home_team = game.get('home_team_name', '')
                away_team = game.get('away_team_name', '')
                game_date = game.get('game_date', '')
                stadium = game.get('stadium', '')
                game_id = game.get('game_id', '')
                
                # Game Preview APIÎ°ú ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå
                preview_info = self._get_game_preview_info(game_id)
                
                if preview_info:
                    # ÏÉÅÏÑ∏Ìïú ÎØ∏Î¶¨Î≥¥Í∏∞ Ï†ïÎ≥¥Î°ú ÏòàÏ∏° ÏÉùÏÑ±
                    game_prediction = self._generate_detailed_prediction_response(
                        home_team, away_team, game_date, stadium, preview_info
                    )
                else:
                    # Í∏∞Î≥∏ ÏÉÅÎåÄÏ†ÑÏ†Å Î∂ÑÏÑù (Ìè¥Î∞±)
                    prediction_analysis = self._analyze_head_to_head_stats(home_team, away_team)
                    home_team_stats = self._get_team_recent_stats(home_team)
                    away_team_stats = self._get_team_recent_stats(away_team)
                    
                    game_prediction = self._generate_prediction_response(
                        home_team, away_team, game_date, stadium, 
                        prediction_analysis, home_team_stats, away_team_stats
                    )
                
                predictions.append(f"üèüÔ∏è {home_team} vs {away_team}\n{game_prediction}")
            
            # Ï†ÑÏ≤¥ ÎãµÎ≥Ä Íµ¨ÏÑ±
            if len(games) == 1:
                return f"üìÖ {date_title}\n\n{predictions[0]}"
            else:
                return f"üìÖ {date_title} ({len(games)}Í≤ΩÍ∏∞)\n\n" + "\n\n".join(predictions)
                
        except Exception as e:
            print(f"‚ùå ÎØ∏Îûò Í≤ΩÍ∏∞ ÏòàÏ∏° ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞ ÏòàÏ∏° ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _get_date_title(self, question: str, games: list) -> str:
        """ÏßàÎ¨∏Í≥º Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞Î•º Î∞îÌÉïÏúºÎ°ú Ï†úÎ™© ÏÉùÏÑ±"""
        try:
            question_lower = question.lower()
            
            # ÏÉÅÎåÄÏ†Å ÎÇ†Ïßú ÌëúÌòÑ Ï≤òÎ¶¨
            if "ÎÇ¥Ïùº" in question_lower:
                return "ÎÇ¥Ïùº Í≤ΩÍ∏∞ ÏòàÏ∏°"
            elif "Î™®Î†à" in question_lower:
                return "Î™®Î†à Í≤ΩÍ∏∞ ÏòàÏ∏°"
            elif "Í∏ÄÌîº" in question_lower:
                return "Í∏ÄÌîº Í≤ΩÍ∏∞ ÏòàÏ∏°"
            elif "Îã§Ïùå Ï£º" in question_lower:
                return "Îã§Ïùå Ï£º Í≤ΩÍ∏∞ ÏòàÏ∏°"
            elif "Ïù¥Î≤à Ï£º" in question_lower:
                return "Ïù¥Î≤à Ï£º Í≤ΩÍ∏∞ ÏòàÏ∏°"
            elif "ÏïûÏúºÎ°ú" in question_lower or "ÏïûÏúºÎ°ú ÎÇ®ÏùÄ" in question_lower:
                return "ÏïûÏúºÎ°ú ÎÇ®ÏùÄ Í≤ΩÍ∏∞ ÏòàÏ∏°"
            elif "Ïò§Îäò" in question_lower:
                return "Ïò§Îäò Í≤ΩÍ∏∞ ÏòàÏ∏°"
            
            # Íµ¨Ï≤¥Ï†ÅÏù∏ ÎÇ†ÏßúÍ∞Ä ÏûàÎäî Í≤ΩÏö∞
            if games:
                first_game_date = games[0].get('game_date', '')
                if first_game_date:
                    from datetime import datetime
                    try:
                        date_obj = datetime.strptime(first_game_date, '%Y-%m-%d')
                        formatted_date = date_obj.strftime('%mÏõî %dÏùº')
                        return f"{formatted_date} Í≤ΩÍ∏∞ ÏòàÏ∏°"
                    except:
                        pass
            
            # Í∏∞Î≥∏Í∞í
            return "Í≤ΩÍ∏∞ ÏòàÏ∏°"
            
        except Exception as e:
            print(f"‚ùå ÎÇ†Ïßú Ï†úÎ™© ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return "Í≤ΩÍ∏∞ ÏòàÏ∏°"
    
    def _get_game_preview_info(self, game_id: str) -> dict:
        """Game Preview APIÎ°ú Í≤ΩÍ∏∞ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        try:
            if not game_id:
                return None
            
            print(f"üîç Game Preview API Ìò∏Ï∂ú: {game_id}")
            
            # ÎèôÍ∏∞Ï†ÅÏúºÎ°ú API Ìò∏Ï∂ú (httpxÎ•º ÎèôÍ∏∞ Î™®ÎìúÎ°ú ÏÇ¨Ïö©)
            import httpx
            
            url = f"https://api-gw.sports.naver.com/schedule/games/{game_id}/preview"
            with httpx.Client() as client:
                response = client.get(url)
                response.raise_for_status()
                
                data = response.json()
                
                if data.get("code") == 200 and data.get("success"):
                    preview_data = data.get("result", {}).get("previewData")
                    if preview_data:
                        print(f"‚úÖ Game Preview Îç∞Ïù¥ÌÑ∞ ÏàòÏã† ÏÑ±Í≥µ: {game_id}")
                        return game_preview_service.analyze_game_preview(preview_data)
                
                print(f"‚ùå Game Preview API Ïã§Ìå®: {game_id}")
                return None
                
        except Exception as e:
            print(f"‚ùå Game Preview API Ïò§Î•ò: {e}")
            return None
    
    def _generate_detailed_prediction_response(self, home_team: str, away_team: str, 
                                            game_date: str, stadium: str, preview_info: dict) -> str:
        """Game Preview Ï†ïÎ≥¥Î•º ÌôúÏö©Ìïú ÏÉÅÏÑ∏ ÏòàÏ∏° ÎãµÎ≥Ä ÏÉùÏÑ±"""
        try:
            game_info = preview_info.get("game_info", {})
            team_standings = preview_info.get("team_standings", {})
            starters = preview_info.get("starters", {})
            key_players = preview_info.get("key_players", {})
            season_h2h = preview_info.get("season_head_to_head", {})
            
            # Í∏∞Î≥∏ Í≤ΩÍ∏∞ Ï†ïÎ≥¥
            response = f"üìÖ {game_date} {stadium}ÏóêÏÑú Ïó¥Î¶¨Îäî {home_team} vs {away_team} Í≤ΩÍ∏∞ ÏòàÏ∏°\n\n"
            
            # ÌåÄ ÏàúÏúÑ Î∞è ÏÑ±Ï†Å
            home_standings = team_standings.get("home", {})
            away_standings = team_standings.get("away", {})
            
            response += f"üèÜ ÌåÄ ÏàúÏúÑ Î∞è ÏÑ±Ï†Å:\n"
            response += f"‚Ä¢ {home_team}: {home_standings.get('rank', 'N/A')}ÏúÑ (ÏäπÎ•† {home_standings.get('wra', 'N/A')})\n"
            response += f"‚Ä¢ {away_team}: {away_standings.get('rank', 'N/A')}ÏúÑ (ÏäπÎ•† {away_standings.get('wra', 'N/A')})\n\n"
            
            # ÏÑ†Î∞úÌà¨Ïàò Ï†ïÎ≥¥
            home_starter = starters.get("home", {})
            away_starter = starters.get("away", {})
            
            response += f"‚öæ ÏÑ†Î∞úÌà¨Ïàò:\n"
            response += f"‚Ä¢ {home_team} - {home_starter.get('name', 'N/A')} (ERA {home_starter.get('era', 'N/A')})\n"
            response += f"‚Ä¢ {away_team} - {away_starter.get('name', 'N/A')} (ERA {away_starter.get('era', 'N/A')})\n\n"
            
            # Ï£ºÏöî ÏÑ†Ïàò Ï†ïÎ≥¥
            home_key_player = key_players.get("home", {})
            away_key_player = key_players.get("away", {})
            
            response += f"üî• Ï£ºÏöî ÏÑ†Ïàò:\n"
            response += f"‚Ä¢ {home_team} - {home_key_player.get('name', 'N/A')} (ÌÉÄÏú® {home_key_player.get('hra', 'N/A')})\n"
            response += f"‚Ä¢ {away_team} - {away_key_player.get('name', 'N/A')} (ÌÉÄÏú® {away_key_player.get('hra', 'N/A')})\n\n"
            
            # ÏãúÏ¶å ÏÉÅÎåÄÏ†ÑÏ†Å
            hw = season_h2h.get("home_wins", 0)
            aw = season_h2h.get("away_wins", 0)
            
            response += f"üìä ÏãúÏ¶å ÏÉÅÎåÄÏ†ÑÏ†Å:\n"
            response += f"‚Ä¢ {home_team} {hw}Ïäπ {aw}Ìå® {away_team}\n\n"
            
            # ÏòàÏ∏° Î∂ÑÏÑù
            response += f"üéØ Í≤ΩÍ∏∞ ÏòàÏÉÅ:\n"
            
            # ÏàúÏúÑ ÎπÑÍµê
            home_rank = home_standings.get('rank', 999)
            away_rank = away_standings.get('rank', 999)
            
            if home_rank < away_rank:
                response += f"‚Ä¢ {home_team}Ïù¥ ÏàúÏúÑÏÉÅ Ïö∞ÏÑ∏ ({home_rank}ÏúÑ vs {away_rank}ÏúÑ)\n"
            elif away_rank < home_rank:
                response += f"‚Ä¢ {away_team}Ïù¥ ÏàúÏúÑÏÉÅ Ïö∞ÏÑ∏ ({away_rank}ÏúÑ vs {home_rank}ÏúÑ)\n"
            else:
                response += f"‚Ä¢ ÏñëÌåÄ ÏàúÏúÑÍ∞Ä ÎπÑÏä∑Ìï® ({home_rank}ÏúÑ vs {away_rank}ÏúÑ)\n"
            
            # ÌôàÍµ¨Ïû• Ïö∞ÏÑ∏
            response += f"‚Ä¢ {home_team}Ïùò ÌôàÍµ¨Ïû• Ïö∞ÏÑ∏\n"
            
            # ÏÑ†Î∞úÌà¨Ïàò ÎπÑÍµê
            home_era = float(home_starter.get('era', 999))
            away_era = float(away_starter.get('era', 999))
            
            if home_era < away_era:
                response += f"‚Ä¢ {home_team} ÏÑ†Î∞úÌà¨ÏàòÍ∞Ä ÏÉÅÎåÄÏ†ÅÏúºÎ°ú Ïö∞Ïàò (ERA {home_era} vs {away_era})\n"
            elif away_era < home_era:
                response += f"‚Ä¢ {away_team} ÏÑ†Î∞úÌà¨ÏàòÍ∞Ä ÏÉÅÎåÄÏ†ÅÏúºÎ°ú Ïö∞Ïàò (ERA {away_era} vs {home_era})\n"
            
            return response
            
        except Exception as e:
            print(f"‚ùå ÏÉÅÏÑ∏ ÏòàÏ∏° ÎãµÎ≥Ä ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞ ÏòàÏ∏° Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _handle_future_game_info(self, question: str) -> str:
        """ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÏßàÎ¨∏ Ï≤òÎ¶¨"""
        try:
            print(f"üîç ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï≤òÎ¶¨ ÏãúÏûë: {question}")
            
            # ÏßàÎ¨∏ÏóêÏÑú ÌåÄÎ™Ö Ï∂îÏ∂ú
            team_names = self._extract_team_names_from_question(question)
            
            # ÏßàÎ¨∏ÏóêÏÑú ÎÇ†Ïßú Ï∂îÏ∂ú
            target_date = self._extract_target_date(question)
            
            # ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå
            if team_names:
                # ÌäπÏ†ï ÌåÄÏùò Í≤ΩÍ∏∞ Ï°∞Ìöå
                games = self._get_team_future_games(team_names, target_date)
            else:
                # Î™®Îì† ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå
                games = self._get_future_games(question)
            
            if not games:
                return "Ìï¥Îãπ Ï°∞Í±¥Ïóê ÎßûÎäî Í≤ΩÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            # ÏßàÎ¨∏ Ïú†ÌòïÏóê Îî∞Î•∏ ÎãµÎ≥Ä ÏÉùÏÑ±
            if any(keyword in question.lower() for keyword in ['ÏÑ†Î∞úÌà¨Ïàò', 'ÏÑ†Î∞ú', 'Ìà¨Ïàò']):
                return self._generate_pitcher_info_response(games, question)
            elif any(keyword in question.lower() for keyword in ['ÎùºÏù∏ÏóÖ', 'Ï∂úÏ†Ñ', 'ÏÑ†Ïàò']):
                return self._generate_lineup_info_response(games, question)
            elif any(keyword in question.lower() for keyword in ['Ïñ¥ÎîîÏÑú', 'Í≤ΩÍ∏∞Ïû•', 'Ïñ∏Ï†ú', 'Î™áÏãú', 'ÏãúÍ∞Ñ']):
                return self._generate_venue_time_info_response(games, question)
            else:
                return self._generate_general_game_info_response(games, question)
                
        except Exception as e:
            print(f"‚ùå ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
            return f"ÎØ∏Îûò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _get_team_future_games(self, team_names: list, target_date: str = None) -> list:
        """ÌäπÏ†ï ÌåÄÏùò ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå"""
        try:
            from datetime import datetime, timedelta
            
            if not target_date:
                today = datetime.now().strftime("%Y-%m-%d")
                future_date = (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d")
            else:
                today = target_date
                future_date = target_date
            
            games = []
            for team in team_names:
                # Ìôà Í≤ΩÍ∏∞ Ï°∞Ìöå
                home_games = self.supabase.supabase.table("game_schedule").select("*").eq("home_team_name", team).gte("game_date", today).lte("game_date", future_date).execute()
                # ÏõêÏ†ï Í≤ΩÍ∏∞ Ï°∞Ìöå
                away_games = self.supabase.supabase.table("game_schedule").select("*").eq("away_team_name", team).gte("game_date", today).lte("game_date", future_date).execute()
                
                if home_games.data:
                    games.extend(home_games.data)
                if away_games.data:
                    games.extend(away_games.data)
            
            # ÎÇ†ÏßúÏàú Ï†ïÎ†¨
            games.sort(key=lambda x: x.get('game_date', ''))
            return games
            
        except Exception as e:
            print(f"‚ùå ÌåÄÎ≥Ñ ÎØ∏Îûò Í≤ΩÍ∏∞ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return []
    
    def _generate_pitcher_info_response(self, games: list, question: str) -> str:
        """ÏÑ†Î∞úÌà¨Ïàò Ï†ïÎ≥¥ ÎãµÎ≥Ä ÏÉùÏÑ±"""
        try:
            if not games:
                return "Ìï¥Îãπ Ï°∞Í±¥Ïóê ÎßûÎäî Í≤ΩÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            responses = []
            for game in games:
                home_team = game.get('home_team_name', '')
                away_team = game.get('away_team_name', '')
                game_date = game.get('game_date', '')
                stadium = game.get('stadium', '')
                game_id = game.get('game_id', '')
                
                # Game Preview APIÎ°ú ÏÑ†Î∞úÌà¨Ïàò Ï†ïÎ≥¥ Ï°∞Ìöå
                preview_info = self._get_game_preview_info(game_id)
                
                if preview_info and preview_info.get('starters'):
                    starters = preview_info['starters']
                    home_starter = starters.get('home', {})
                    away_starter = starters.get('away', {})
                    
                    response = f"‚öæ {game_date} {stadium} - {home_team} vs {away_team}\n"
                    response += f"‚Ä¢ {home_team} ÏÑ†Î∞ú: {home_starter.get('name', 'ÎØ∏Ï†ï')} (Îì±Î≤àÌò∏ {home_starter.get('backnum', 'N/A')})\n"
                    response += f"‚Ä¢ {away_team} ÏÑ†Î∞ú: {away_starter.get('name', 'ÎØ∏Ï†ï')} (Îì±Î≤àÌò∏ {away_starter.get('backnum', 'N/A')})\n"
                    
                    if home_starter.get('era') and home_starter.get('era') != '0.00':
                        response += f"  - {home_starter.get('name', '')} ÏãúÏ¶å ÏÑ±Ï†Å: {home_starter.get('w', 0)}Ïäπ {home_starter.get('l', 0)}Ìå®, ERA {home_starter.get('era', 'N/A')}\n"
                    if away_starter.get('era') and away_starter.get('era') != '0.00':
                        response += f"  - {away_starter.get('name', '')} ÏãúÏ¶å ÏÑ±Ï†Å: {away_starter.get('w', 0)}Ïäπ {away_starter.get('l', 0)}Ìå®, ERA {away_starter.get('era', 'N/A')}\n"
                else:
                    response = f"‚öæ {game_date} {stadium} - {home_team} vs {away_team}\n"
                    response += "‚Ä¢ ÏÑ†Î∞úÌà¨Ïàò Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.\n"
                
                responses.append(response)
            
            return "\n".join(responses)
            
        except Exception as e:
            print(f"‚ùå ÏÑ†Î∞úÌà¨Ïàò Ï†ïÎ≥¥ ÎãµÎ≥Ä ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"ÏÑ†Î∞úÌà¨Ïàò Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _generate_lineup_info_response(self, games: list, question: str) -> str:
        """ÎùºÏù∏ÏóÖ Ï†ïÎ≥¥ ÎãµÎ≥Ä ÏÉùÏÑ±"""
        try:
            if not games:
                return "Ìï¥Îãπ Ï°∞Í±¥Ïóê ÎßûÎäî Í≤ΩÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            responses = []
            for game in games:
                home_team = game.get('home_team_name', '')
                away_team = game.get('away_team_name', '')
                game_date = game.get('game_date', '')
                stadium = game.get('stadium', '')
                game_id = game.get('game_id', '')
                
                # Game Preview APIÎ°ú ÎùºÏù∏ÏóÖ Ï†ïÎ≥¥ Ï°∞Ìöå
                preview_info = self._get_game_preview_info(game_id)
                
                if preview_info and preview_info.get('lineups'):
                    lineups = preview_info['lineups']
                    home_lineup = lineups.get('home', [])
                    away_lineup = lineups.get('away', [])
                    
                    response = f"üìã {game_date} {stadium} - {home_team} vs {away_team}\n"
                    
                    if home_lineup:
                        response += f"‚Ä¢ {home_team} ÎùºÏù∏ÏóÖ:\n"
                        for player in home_lineup[:9]:  # ÏÑ†Î∞ú 9Î™ÖÎßå
                            position = player.get('positionName', 'N/A')
                            name = player.get('playerName', 'N/A')
                            backnum = player.get('backnum', 'N/A')
                            response += f"  {position}: {name} ({backnum}Î≤à)\n"
                    
                    if away_lineup:
                        response += f"‚Ä¢ {away_team} ÎùºÏù∏ÏóÖ:\n"
                        for player in away_lineup[:9]:  # ÏÑ†Î∞ú 9Î™ÖÎßå
                            position = player.get('positionName', 'N/A')
                            name = player.get('playerName', 'N/A')
                            backnum = player.get('backnum', 'N/A')
                            response += f"  {position}: {name} ({backnum}Î≤à)\n"
                else:
                    response = f"üìã {game_date} {stadium} - {home_team} vs {away_team}\n"
                    response += "‚Ä¢ ÎùºÏù∏ÏóÖ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.\n"
                
                responses.append(response)
            
            return "\n".join(responses)
            
        except Exception as e:
            print(f"‚ùå ÎùºÏù∏ÏóÖ Ï†ïÎ≥¥ ÎãµÎ≥Ä ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"ÎùºÏù∏ÏóÖ Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _generate_venue_time_info_response(self, games: list, question: str) -> str:
        """Í≤ΩÍ∏∞Ïû•/ÏãúÍ∞Ñ Ï†ïÎ≥¥ ÎãµÎ≥Ä ÏÉùÏÑ±"""
        try:
            if not games:
                return "Ìï¥Îãπ Ï°∞Í±¥Ïóê ÎßûÎäî Í≤ΩÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            responses = []
            for game in games:
                home_team = game.get('home_team_name', '')
                away_team = game.get('away_team_name', '')
                game_date = game.get('game_date', '')
                stadium = game.get('stadium', '')
                game_time = game.get('game_time', '18:30')
                
                response = f"üèüÔ∏è {game_date} - {home_team} vs {away_team}\n"
                response += f"‚Ä¢ Í≤ΩÍ∏∞Ïû•: {stadium}\n"
                response += f"‚Ä¢ Í≤ΩÍ∏∞ÏãúÍ∞Ñ: {game_time}\n"
                
                responses.append(response)
            
            return "\n".join(responses)
            
        except Exception as e:
            print(f"‚ùå Í≤ΩÍ∏∞Ïû•/ÏãúÍ∞Ñ Ï†ïÎ≥¥ ÎãµÎ≥Ä ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞Ïû•/ÏãúÍ∞Ñ Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _generate_general_game_info_response(self, games: list, question: str) -> str:
        """ÏùºÎ∞òÏ†ÅÏù∏ Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÎãµÎ≥Ä ÏÉùÏÑ±"""
        try:
            if not games:
                return "Ìï¥Îãπ Ï°∞Í±¥Ïóê ÎßûÎäî Í≤ΩÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            
            responses = []
            for game in games:
                home_team = game.get('home_team_name', '')
                away_team = game.get('away_team_name', '')
                game_date = game.get('game_date', '')
                stadium = game.get('stadium', '')
                game_time = game.get('game_time', '18:30')
                game_id = game.get('game_id', '')
                
                response = f"üìÖ {game_date} - {home_team} vs {away_team}\n"
                response += f"‚Ä¢ Í≤ΩÍ∏∞Ïû•: {stadium}\n"
                response += f"‚Ä¢ Í≤ΩÍ∏∞ÏãúÍ∞Ñ: {game_time}\n"
                
                # Game Preview APIÎ°ú Ï∂îÍ∞Ä Ï†ïÎ≥¥ Ï°∞Ìöå
                preview_info = self._get_game_preview_info(game_id)
                if preview_info and preview_info.get('starters'):
                    starters = preview_info['starters']
                    home_starter = starters.get('home', {})
                    away_starter = starters.get('away', {})
                    
                    if home_starter.get('name'):
                        response += f"‚Ä¢ {home_team} ÏÑ†Î∞ú: {home_starter.get('name')}\n"
                    if away_starter.get('name'):
                        response += f"‚Ä¢ {away_team} ÏÑ†Î∞ú: {away_starter.get('name')}\n"
                
                responses.append(response)
            
            return "\n".join(responses)
            
        except Exception as e:
            print(f"‚ùå ÏùºÎ∞ò Í≤ΩÍ∏∞ Ï†ïÎ≥¥ ÎãµÎ≥Ä ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"Í≤ΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"
    
    def _extract_team_names_from_question(self, question: str) -> list:
        """ÏßàÎ¨∏ÏóêÏÑú ÌåÄÎ™Ö Ï∂îÏ∂ú"""
        team_names = []
        team_keywords = ['ÌïúÌôî', 'ÎëêÏÇ∞', 'KIA', 'ÌÇ§ÏõÄ', 'Î°ØÎç∞', 'ÏÇºÏÑ±', 'SSG', 'KT', 'NC', 'LG']
        
        for team in team_keywords:
            if team in question:
                team_names.append(team)
        
        return team_names
    
    def _get_next_game_for_teams(self, team_names: list) -> dict:
        """Ìï¥Îãπ ÌåÄÎì§Ïùò Îã§Ïùå Í≤ΩÍ∏∞ Ï°∞Ìöå"""
        try:
            from datetime import datetime
            today = datetime.now().strftime("%Y-%m-%d")
            
            for team in team_names:
                # ÌôàÌåÄÏúºÎ°ú Ï∞∏Ïó¨ÌïòÎäî Í≤ΩÍ∏∞
                home_query = self.supabase.supabase.table("game_schedule").select("*")
                home_query = home_query.eq("home_team_name", team)
                home_query = home_query.gte("game_date", today)
                home_query = home_query.order("game_date").limit(1)
                home_result = home_query.execute()
                
                if home_result.data:
                    return home_result.data[0]
                
                # ÏõêÏ†ïÌåÄÏúºÎ°ú Ï∞∏Ïó¨ÌïòÎäî Í≤ΩÍ∏∞
                away_query = self.supabase.supabase.table("game_schedule").select("*")
                away_query = away_query.eq("away_team_name", team)
                away_query = away_query.gte("game_date", today)
                away_query = away_query.order("game_date").limit(1)
                away_result = away_query.execute()
                
                if away_result.data:
                    return away_result.data[0]
            
            return None
            
        except Exception as e:
            print(f"‚ùå Îã§Ïùå Í≤ΩÍ∏∞ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return None
    
    def _analyze_head_to_head_stats(self, home_team: str, away_team: str) -> dict:
        """ÏÉÅÎåÄÏ†ÑÏ†Å Î∂ÑÏÑù"""
        try:
            # game_result ÌÖåÏù¥Î∏îÏóêÏÑú Îëê ÌåÄÏùò ÌòÑÏû¨ ÏÑ±Ï†Å Ï°∞Ìöå
            home_stats = self.supabase.supabase.table("game_result").select("*").eq("team_name", home_team).execute()
            away_stats = self.supabase.supabase.table("game_result").select("*").eq("team_name", away_team).execute()
            
            if not home_stats.data or not away_stats.data:
                return {"error": "ÌåÄ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."}
            
            home_data = home_stats.data[0]
            away_data = away_stats.data[0]
            
            # ÏÉÅÎåÄÏ†ÑÏ†Å Î∂ÑÏÑù Í≤∞Í≥º
            analysis = {
                "home_team": {
                    "name": home_team,
                    "ranking": home_data.get("ranking", 0),
                    "wra": home_data.get("wra", 0.0),
                    "last_five": home_data.get("last_five_games", ""),
                    "offense_ops": home_data.get("offense_ops", 0.0),
                    "defense_era": home_data.get("defense_era", 0.0)
                },
                "away_team": {
                    "name": away_team,
                    "ranking": away_data.get("ranking", 0),
                    "wra": away_data.get("wra", 0.0),
                    "last_five": away_data.get("last_five_games", ""),
                    "offense_ops": away_data.get("offense_ops", 0.0),
                    "defense_era": away_data.get("defense_era", 0.0)
                }
            }
            
            return analysis
            
        except Exception as e:
            print(f"‚ùå ÏÉÅÎåÄÏ†ÑÏ†Å Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return {"error": f"ÏÉÅÎåÄÏ†ÑÏ†Å Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {str(e)}"}
    
    def _get_team_recent_stats(self, team_name: str) -> dict:
        """ÌåÄÏùò ÏµúÍ∑º ÏÑ±Ï†Å Ï°∞Ìöå"""
        try:
            result = self.supabase.supabase.table("game_result").select("*").eq("team_name", team_name).execute()
            
            if result.data:
                return result.data[0]
            return {}
            
        except Exception as e:
            print(f"‚ùå ÌåÄ ÏÑ±Ï†Å Ï°∞Ìöå Ïò§Î•ò: {e}")
            return {}
    
    def _generate_prediction_response(self, home_team: str, away_team: str, game_date: str, 
                                    stadium: str, prediction_analysis: dict, 
                                    home_team_stats: dict, away_team_stats: dict) -> str:
        """ÏòàÏ∏° ÎãµÎ≥Ä ÏÉùÏÑ±"""
        try:
            if "error" in prediction_analysis:
                return f"üìÖ {game_date} {stadium}ÏóêÏÑú Ïó¥Î¶¨Îäî {home_team} vs {away_team} Í≤ΩÍ∏∞\n\n{prediction_analysis['error']}"
            
            home_data = prediction_analysis["home_team"]
            away_data = prediction_analysis["away_team"]
            
            # ÏòàÏ∏° Î°úÏßÅ (Í∞ÑÎã®Ìïú ÎπÑÍµê)
            home_advantage = 0
            if home_data["ranking"] < away_data["ranking"]:  # ÏàúÏúÑÍ∞Ä ÎÜíÏúºÎ©¥ (Ïà´ÏûêÍ∞Ä ÏûëÏúºÎ©¥)
                home_advantage += 1
            if home_data["wra"] > away_data["wra"]:  # ÏäπÎ•†Ïù¥ ÎÜíÏúºÎ©¥
                home_advantage += 1
            if home_data["offense_ops"] > away_data["offense_ops"]:  # Í≥µÍ≤©Î†•Ïù¥ Ï¢ãÏúºÎ©¥
                home_advantage += 1
            if home_data["defense_era"] < away_data["defense_era"]:  # ÏàòÎπÑÎ†•Ïù¥ Ï¢ãÏúºÎ©¥ (ERAÍ∞Ä ÎÇÆÏúºÎ©¥)
                home_advantage += 1
            
            # ÏµúÍ∑º 5Í≤ΩÍ∏∞ Î∂ÑÏÑù
            home_recent = home_data["last_five"].count("W") if home_data["last_five"] else 0
            away_recent = away_data["last_five"].count("W") if away_data["last_five"] else 0
            
            # ÏòàÏ∏° Í≤∞Í≥º
            if home_advantage >= 3:
                prediction = f"üèÜ {home_team} ÏäπÎ¶¨ ÏòàÏÉÅ"
                confidence = "ÎÜíÏùå"
            elif home_advantage <= 1:
                prediction = f"üèÜ {away_team} ÏäπÎ¶¨ ÏòàÏÉÅ"
                confidence = "ÎÜíÏùå"
            else:
                prediction = "‚öñÔ∏è Ï†ëÏ†Ñ ÏòàÏÉÅ"
                confidence = "Î≥¥ÌÜµ"
            
            # ÎãµÎ≥Ä ÏÉùÏÑ±
            response = f"""üìÖ {game_date} {stadium}ÏóêÏÑú Ïó¥Î¶¨Îäî {home_team} vs {away_team} Í≤ΩÍ∏∞ ÏòàÏ∏°

üèüÔ∏è Í≤ΩÍ∏∞ Ï†ïÎ≥¥:
‚Ä¢ ÎÇ†Ïßú: {game_date}
‚Ä¢ Í≤ΩÍ∏∞Ïû•: {stadium}
‚Ä¢ ÌôàÌåÄ: {home_team}
‚Ä¢ ÏõêÏ†ïÌåÄ: {away_team}

üìä ÏÉÅÎåÄÏ†ÑÏ†Å Î∂ÑÏÑù:
‚Ä¢ {home_team}: {home_data['ranking']}ÏúÑ (ÏäπÎ•† {home_data['wra']:.3f})
‚Ä¢ {away_team}: {away_data['ranking']}ÏúÑ (ÏäπÎ•† {away_data['wra']:.3f})

‚öæ Í≥µÍ≤©Î†• ÎπÑÍµê:
‚Ä¢ {home_team} OPS: {home_data['offense_ops']:.3f}
‚Ä¢ {away_team} OPS: {away_data['offense_ops']:.3f}

ü•é ÏàòÎπÑÎ†• ÎπÑÍµê:
‚Ä¢ {home_team} ERA: {home_data['defense_era']:.2f}
‚Ä¢ {away_team} ERA: {away_data['defense_era']:.2f}

üìà ÏµúÍ∑º 5Í≤ΩÍ∏∞:
‚Ä¢ {home_team}: {home_data['last_five']} ({home_recent}Ïäπ)
‚Ä¢ {away_team}: {away_data['last_five']} ({away_recent}Ïäπ)

üéØ ÏòàÏ∏° Í≤∞Í≥º: {prediction} (Ïã†Î¢∞ÎèÑ: {confidence})

üí° ÌåÅ: Ïã§Ï†ú Í≤ΩÍ∏∞ Í≤∞Í≥ºÎäî ÏòàÏ∏°Í≥º Îã§Î•º Ïàò ÏûàÏúºÎãà Í≤ΩÍ∏∞Î•º ÏßÅÏ†ë Í¥ÄÎûåÌï¥Î≥¥ÏÑ∏Ïöî!"""
            
            return response
            
        except Exception as e:
            print(f"‚ùå ÏòàÏ∏° ÎãµÎ≥Ä ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return f"ÏòàÏ∏° ÎãµÎ≥Ä ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}"

def main():
    """ÌÖåÏä§Ìä∏ Ìï®Ïàò"""
    try:
        rag_text_to_sql = RAGTextToSQL()
        
        # ÌÖåÏä§Ìä∏ ÏßàÎ¨∏Îì§
        test_questions = [
            "ÌïúÌôî ÎßàÏßÄÎßâ Ïö∞ÏäπÎÖÑÎèÑ",
            "ÌïúÌôî Ïò¨Ìï¥ Î™áÎì±Ïù¥Ïïº?",
            "Î¨∏ÎèôÏ£º ÏÑ†Ïàò ÏÑ±Ï†ÅÏù¥ Ïñ¥Îïå?",
            "Ïò§Îäò Í≤ΩÍ∏∞ ÏùºÏ†ï",
            "ÎëêÏÇ∞ Ìà¨Ïàò Ï§ëÏóê Í∞ÄÏû• ÏûòÌïòÎäî Ìà¨ÏàòÍ∞Ä ÎàÑÍµ¨Ïïº?"
        ]
        
        for question in test_questions:
            print(f"\n{'='*50}")
            print(f"ÏßàÎ¨∏: {question}")
            answer = rag_text_to_sql.process_question(question)
            print(f"ÎãµÎ≥Ä: {answer}")
            
    except Exception as e:
        print(f"‚ùå ÌÖåÏä§Ìä∏ Ïã§Ìå®: {e}")

if __name__ == "__main__":
    main()
